/******************************************************************************
* The MIT License (MIT)
*
* Copyright (c) 2020-2021 Baldur Karlsson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
******************************************************************************/

/******************************************************************************
* The MIT License (MIT)
*
* Copyright (c) 2022-2023 xiongya
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
******************************************************************************/

/******************************************************************************
* Generated from Khronos's vk.xml:

* Copyright 2015-2022 The Khronos Group Inc.
* 
* SPDX-License-Identifier: Apache-2.0 OR MIT
* 
* This file, vk.xml, is the Vulkan API Registry. It is a critically important
* and normative part of the Vulkan Specification, including a canonical
* machine-readable definition of the API, parameter and member validation
* language incorporated into the Specification and reference pages, and other
* material which is registered by Khronos, such as tags used by extension and
* layer authors. The authoritative public version of vk.xml is maintained in
* the default branch (currently named main) of the Khronos Vulkan GitHub
* project. The authoritative private version is maintained in the default
* branch of the member gitlab server.
* 

******************************************************************************/
// This file is autogenerated with vk_xml_parser.py - any changes will be overwritten next time
// that script is run.
// $ ./vk_xml_parser.py

#pragma once

// this file is autogenerated, so don't worry about clang-format issues
// clang-format off
#include"vk_common.h"


struct WSpecializationMapEntry:public VkSpecializationMapEntry{
	WSpecializationMapEntry(): VkSpecializationMapEntry{}{}
};

struct WExtent2D:public VkExtent2D{
	WExtent2D(): VkExtent2D{}{}
};

struct WAttachmentReference2:public VkAttachmentReference2{
	WAttachmentReference2(): VkAttachmentReference2{}{
		sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
	}
};

struct WMemoryHeap:public VkMemoryHeap{
	WMemoryHeap(): VkMemoryHeap{}{}
};

struct WMemoryType:public VkMemoryType{
	WMemoryType(): VkMemoryType{}{}
};

struct WPhysicalDeviceSparseProperties:public VkPhysicalDeviceSparseProperties{
	WPhysicalDeviceSparseProperties(): VkPhysicalDeviceSparseProperties{}{}
};

struct WPhysicalDeviceLimits:public VkPhysicalDeviceLimits{
	WPhysicalDeviceLimits(): VkPhysicalDeviceLimits{}{}
};

struct WSparseImageFormatProperties:public VkSparseImageFormatProperties{
	WSparseImageFormatProperties(): VkSparseImageFormatProperties{}{}
};

struct WAttachmentReference:public VkAttachmentReference{
	WAttachmentReference(): VkAttachmentReference{}{}
};

struct WSpecializationInfo:public VkSpecializationInfo{
	WSpecializationInfo(): VkSpecializationInfo{}{}
	void setMapEntries(std::vector<WSpecializationMapEntry> const& mapEntries){
		this->mapEntryCount = mapEntries.size();
		this->pMapEntries = mapEntries.data();
	}
	void setData(std::vector<uint8_t> const& data){
		this->dataSize = data.size();
		this->pData = (void*)data.data();
	}
};

struct WVertexInputAttributeDescription:public VkVertexInputAttributeDescription{
	WVertexInputAttributeDescription(): VkVertexInputAttributeDescription{}{}
};

struct WVertexInputBindingDescription:public VkVertexInputBindingDescription{
	WVertexInputBindingDescription(): VkVertexInputBindingDescription{}{}
};

struct WRect2D:public VkRect2D{
	WRect2D(): VkRect2D{}{}
};

struct WStencilOpState:public VkStencilOpState{
	WStencilOpState(): VkStencilOpState{}{}
};

struct WPipelineColorBlendAttachmentState:public VkPipelineColorBlendAttachmentState{
	WPipelineColorBlendAttachmentState(): VkPipelineColorBlendAttachmentState{}{}
};

struct WSparseMemoryBind:public VkSparseMemoryBind{
	WSparseMemoryBind(): VkSparseMemoryBind{}{}
};

struct WSparseImageMemoryBind:public VkSparseImageMemoryBind{
	WSparseImageMemoryBind(): VkSparseImageMemoryBind{}{}
};

struct WApplicationInfo:public VkApplicationInfo{
	WApplicationInfo(): VkApplicationInfo{}{
		sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
	}
	void setApplicationName(std::string const& applicationName){
		this->pApplicationName = applicationName.c_str();
	}
	void setEngineName(std::string const& engineName){
		this->pEngineName = engineName.c_str();
	}
};

struct WDeviceQueueCreateInfo:public VkDeviceQueueCreateInfo{
	WDeviceQueueCreateInfo(): VkDeviceQueueCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
	}
	void setQueuePriorities(std::vector<float> const& queuePriorities){
		this->queueCount = queuePriorities.size();
		this->pQueuePriorities = queuePriorities.data();
	}
};

struct WSparseImageMemoryBindInfo:public VkSparseImageMemoryBindInfo{
	WSparseImageMemoryBindInfo(): VkSparseImageMemoryBindInfo{}{}
	void setBinds(std::vector<WSparseImageMemoryBind> const& binds){
		this->bindCount = binds.size();
		this->pBinds = binds.data();
	}
};

struct WSparseImageOpaqueMemoryBindInfo:public VkSparseImageOpaqueMemoryBindInfo{
	WSparseImageOpaqueMemoryBindInfo(): VkSparseImageOpaqueMemoryBindInfo{}{}
	void setBinds(std::vector<WSparseMemoryBind> const& binds){
		this->bindCount = binds.size();
		this->pBinds = binds.data();
	}
};

struct WSparseBufferMemoryBindInfo:public VkSparseBufferMemoryBindInfo{
	WSparseBufferMemoryBindInfo(): VkSparseBufferMemoryBindInfo{}{}
	void setBinds(std::vector<WSparseMemoryBind> const& binds){
		this->bindCount = binds.size();
		this->pBinds = binds.data();
	}
};

struct WPipelineDynamicStateCreateInfo:public VkPipelineDynamicStateCreateInfo{
	WPipelineDynamicStateCreateInfo(): VkPipelineDynamicStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
	}
	void setDynamicStates(std::vector<VkDynamicState> const& dynamicStates){
		this->dynamicStateCount = dynamicStates.size();
		this->pDynamicStates = dynamicStates.data();
	}
};

struct WPipelineColorBlendStateCreateInfo:public VkPipelineColorBlendStateCreateInfo{
	WPipelineColorBlendStateCreateInfo(): VkPipelineColorBlendStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
	}
	void setAttachments(std::vector<WPipelineColorBlendAttachmentState> const& attachments){
		this->attachmentCount = attachments.size();
		this->pAttachments = attachments.data();
	}
};

struct WPipelineDepthStencilStateCreateInfo:public VkPipelineDepthStencilStateCreateInfo{
	WPipelineDepthStencilStateCreateInfo(): VkPipelineDepthStencilStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
	}
};

struct WPipelineMultisampleStateCreateInfo:public VkPipelineMultisampleStateCreateInfo{
	WPipelineMultisampleStateCreateInfo(): VkPipelineMultisampleStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
	}
};

struct WPipelineRasterizationStateCreateInfo:public VkPipelineRasterizationStateCreateInfo{
	WPipelineRasterizationStateCreateInfo(): VkPipelineRasterizationStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
	}
};

struct WPipelineViewportStateCreateInfo:public VkPipelineViewportStateCreateInfo{
	WPipelineViewportStateCreateInfo(): VkPipelineViewportStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
	}
	void setViewports(std::vector<VkViewport> const& viewports){
		this->viewportCount = viewports.size();
		this->pViewports = viewports.data();
	}
	void setScissors(std::vector<WRect2D> const& scissors){
		this->scissorCount = scissors.size();
		this->pScissors = scissors.data();
	}
};

struct WPipelineTessellationStateCreateInfo:public VkPipelineTessellationStateCreateInfo{
	WPipelineTessellationStateCreateInfo(): VkPipelineTessellationStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
	}
};

struct WPipelineInputAssemblyStateCreateInfo:public VkPipelineInputAssemblyStateCreateInfo{
	WPipelineInputAssemblyStateCreateInfo(): VkPipelineInputAssemblyStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	}
};

struct WPipelineVertexInputStateCreateInfo:public VkPipelineVertexInputStateCreateInfo{
	WPipelineVertexInputStateCreateInfo(): VkPipelineVertexInputStateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	}
	void setVertexBindingDescriptions(std::vector<WVertexInputBindingDescription> const& vertexBindingDescriptions){
		this->vertexBindingDescriptionCount = vertexBindingDescriptions.size();
		this->pVertexBindingDescriptions = vertexBindingDescriptions.data();
	}
	void setVertexAttributeDescriptions(std::vector<WVertexInputAttributeDescription> const& vertexAttributeDescriptions){
		this->vertexAttributeDescriptionCount = vertexAttributeDescriptions.size();
		this->pVertexAttributeDescriptions = vertexAttributeDescriptions.data();
	}
};

struct WPipelineShaderStageCreateInfo:public VkPipelineShaderStageCreateInfo{
	WPipelineShaderStageCreateInfo(): VkPipelineShaderStageCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	}
	void setName(std::string const& name){
		this->pName = name.c_str();
	}
};

struct WPushConstantRange:public VkPushConstantRange{
	WPushConstantRange(): VkPushConstantRange{}{}
};

struct WDescriptorSetLayoutBinding:public VkDescriptorSetLayoutBinding{
	WDescriptorSetLayoutBinding(): VkDescriptorSetLayoutBinding{}{}
	void setImmutableSamplers(std::vector<VkSampler> const& immutableSamplers){
		this->descriptorCount = immutableSamplers.size();
		this->pImmutableSamplers = immutableSamplers.data();
	}
};

struct WDescriptorPoolSize:public VkDescriptorPoolSize{
	WDescriptorPoolSize(): VkDescriptorPoolSize{}{}
};

struct WDescriptorBufferInfo:public VkDescriptorBufferInfo{
	WDescriptorBufferInfo(): VkDescriptorBufferInfo{}{}
};

struct WDescriptorImageInfo:public VkDescriptorImageInfo{
	WDescriptorImageInfo(): VkDescriptorImageInfo{}{}
};

struct WSubpassDependency:public VkSubpassDependency{
	WSubpassDependency(): VkSubpassDependency{}{}
};

struct WSubpassDescription:public VkSubpassDescription{
	WSubpassDescription(): VkSubpassDescription{}{}
	void setInputAttachments(std::vector<WAttachmentReference> const& inputAttachments){
		this->inputAttachmentCount = inputAttachments.size();
		this->pInputAttachments = inputAttachments.data();
	}
	void setColorAttachments(std::vector<WAttachmentReference> const& colorAttachments){
		this->colorAttachmentCount = colorAttachments.size();
		this->pColorAttachments = colorAttachments.data();
	}
	void setResolveAttachments(std::vector<WAttachmentReference> const& resolveAttachments){
		rs_check( this->colorAttachmentCount == resolveAttachments.size());
		this->pResolveAttachments = resolveAttachments.data();
	}
	void setPreserveAttachments(std::vector<uint32_t> const& preserveAttachments){
		this->preserveAttachmentCount = preserveAttachments.size();
		this->pPreserveAttachments = preserveAttachments.data();
	}
};

struct WAttachmentDescription:public VkAttachmentDescription{
	WAttachmentDescription(): VkAttachmentDescription{}{}
};

struct WCommandBufferInheritanceInfo:public VkCommandBufferInheritanceInfo{
	WCommandBufferInheritanceInfo(): VkCommandBufferInheritanceInfo{}{
		sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
	}
};

struct WExtent3D:public VkExtent3D{
	WExtent3D(): VkExtent3D{}{}
};

struct WOffset3D:public VkOffset3D{
	WOffset3D(): VkOffset3D{}{}
};

struct WImageSubresourceLayers:public VkImageSubresourceLayers{
	WImageSubresourceLayers(): VkImageSubresourceLayers{}{}
};

struct WImageSubresourceRange:public VkImageSubresourceRange{
	WImageSubresourceRange(): VkImageSubresourceRange{}{}
};

struct WMemoryRequirements:public VkMemoryRequirements{
	WMemoryRequirements(): VkMemoryRequirements{}{}
};

struct WSparseImageMemoryRequirements:public VkSparseImageMemoryRequirements{
	WSparseImageMemoryRequirements(): VkSparseImageMemoryRequirements{}{}
};

struct WPhysicalDeviceFeatures:public VkPhysicalDeviceFeatures{
	WPhysicalDeviceFeatures(): VkPhysicalDeviceFeatures{}{}
};

struct WPhysicalDeviceProperties:public VkPhysicalDeviceProperties{
	WPhysicalDeviceProperties(): VkPhysicalDeviceProperties{}{}
};

struct WFormatProperties:public VkFormatProperties{
	WFormatProperties(): VkFormatProperties{}{}
};

struct WImageFormatProperties:public VkImageFormatProperties{
	WImageFormatProperties(): VkImageFormatProperties{}{}
};

struct WQueueFamilyProperties:public VkQueueFamilyProperties{
	WQueueFamilyProperties(): VkQueueFamilyProperties{}{}
};

struct WPhysicalDeviceMemoryProperties:public VkPhysicalDeviceMemoryProperties{
	WPhysicalDeviceMemoryProperties(): VkPhysicalDeviceMemoryProperties{}{}
};

struct WComponentMapping:public VkComponentMapping{
	WComponentMapping(): VkComponentMapping{}{}
};

struct WDescriptorUpdateTemplateEntry:public VkDescriptorUpdateTemplateEntry{
	WDescriptorUpdateTemplateEntry(): VkDescriptorUpdateTemplateEntry{}{}
};

struct WExternalMemoryProperties:public VkExternalMemoryProperties{
	WExternalMemoryProperties(): VkExternalMemoryProperties{}{}
};

struct WSubpassDependency2:public VkSubpassDependency2{
	WSubpassDependency2(): VkSubpassDependency2{}{
		sType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
	}
};

struct WSubpassDescription2:public VkSubpassDescription2{
	WSubpassDescription2(): VkSubpassDescription2{}{
		sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
	}
	void setInputAttachments(std::vector<WAttachmentReference2> const& inputAttachments){
		this->inputAttachmentCount = inputAttachments.size();
		this->pInputAttachments = inputAttachments.data();
	}
	void setColorAttachments(std::vector<WAttachmentReference2> const& colorAttachments){
		this->colorAttachmentCount = colorAttachments.size();
		this->pColorAttachments = colorAttachments.data();
	}
	void setResolveAttachments(std::vector<WAttachmentReference2> const& resolveAttachments){
		rs_check( this->colorAttachmentCount == resolveAttachments.size());
		this->pResolveAttachments = resolveAttachments.data();
	}
	void setPreserveAttachments(std::vector<uint32_t> const& preserveAttachments){
		this->preserveAttachmentCount = preserveAttachments.size();
		this->pPreserveAttachments = preserveAttachments.data();
	}
};

struct WAttachmentDescription2:public VkAttachmentDescription2{
	WAttachmentDescription2(): VkAttachmentDescription2{}{
		sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
	}
};

struct WDisplayModeParametersKHR:public VkDisplayModeParametersKHR{
	WDisplayModeParametersKHR(): VkDisplayModeParametersKHR{}{}
};

struct WOffset2D:public VkOffset2D{
	WOffset2D(): VkOffset2D{}{}
};

struct WXYColorEXT:public VkXYColorEXT{
	WXYColorEXT(): VkXYColorEXT{}{}
};

struct WSurfaceCapabilitiesKHR:public VkSurfaceCapabilitiesKHR{
	WSurfaceCapabilitiesKHR(): VkSurfaceCapabilitiesKHR{}{}
};

struct WSurfaceFormatKHR:public VkSurfaceFormatKHR{
	WSurfaceFormatKHR(): VkSurfaceFormatKHR{}{}
};

struct WSampleLocationEXT:public VkSampleLocationEXT{
	WSampleLocationEXT(): VkSampleLocationEXT{}{}
};

struct WDebugReportCallbackCreateInfoEXT:public VkDebugReportCallbackCreateInfoEXT{
	WDebugReportCallbackCreateInfoEXT(): VkDebugReportCallbackCreateInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
	}
};

struct WPhysicalDeviceFragmentShadingRateKHR:public VkPhysicalDeviceFragmentShadingRateKHR{
	WPhysicalDeviceFragmentShadingRateKHR(): VkPhysicalDeviceFragmentShadingRateKHR{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
	}
};

struct WValidationCacheCreateInfoEXT:public VkValidationCacheCreateInfoEXT{
	WValidationCacheCreateInfoEXT(): VkValidationCacheCreateInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
	}
	void setInitialData(std::vector<uint8_t> const& initialData){
		this->initialDataSize = initialData.size();
		this->pInitialData = (void*)initialData.data();
	}
};

struct WMultisamplePropertiesEXT:public VkMultisamplePropertiesEXT{
	WMultisamplePropertiesEXT(): VkMultisamplePropertiesEXT{}{
		sType = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
	}
};

struct WSampleLocationsInfoEXT:public VkSampleLocationsInfoEXT{
	WSampleLocationsInfoEXT(): VkSampleLocationsInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
	}
	void setSampleLocations(std::vector<WSampleLocationEXT> const& sampleLocations){
		this->sampleLocationsCount = sampleLocations.size();
		this->pSampleLocations = sampleLocations.data();
	}
};

struct WSurfaceFormat2KHR:public VkSurfaceFormat2KHR{
	WSurfaceFormat2KHR(): VkSurfaceFormat2KHR{}{
		sType = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
	}
};

struct WSurfaceCapabilities2KHR:public VkSurfaceCapabilities2KHR{
	WSurfaceCapabilities2KHR(): VkSurfaceCapabilities2KHR{}{
		sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
	}
};

struct WPhysicalDeviceSurfaceInfo2KHR:public VkPhysicalDeviceSurfaceInfo2KHR{
	WPhysicalDeviceSurfaceInfo2KHR(): VkPhysicalDeviceSurfaceInfo2KHR{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
	}
};

struct WFenceGetFdInfoKHR:public VkFenceGetFdInfoKHR{
	WFenceGetFdInfoKHR(): VkFenceGetFdInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
	}
};

struct WImportFenceFdInfoKHR:public VkImportFenceFdInfoKHR{
	WImportFenceFdInfoKHR(): VkImportFenceFdInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
	}
};

struct WHdrMetadataEXT:public VkHdrMetadataEXT{
	WHdrMetadataEXT(): VkHdrMetadataEXT{}{
		sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
	}
};

struct WPastPresentationTimingGOOGLE:public VkPastPresentationTimingGOOGLE{
	WPastPresentationTimingGOOGLE(): VkPastPresentationTimingGOOGLE{}{}
};

struct WRefreshCycleDurationGOOGLE:public VkRefreshCycleDurationGOOGLE{
	WRefreshCycleDurationGOOGLE(): VkRefreshCycleDurationGOOGLE{}{}
};

struct WSemaphoreGetFdInfoKHR:public VkSemaphoreGetFdInfoKHR{
	WSemaphoreGetFdInfoKHR(): VkSemaphoreGetFdInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
	}
};

struct WImportSemaphoreFdInfoKHR:public VkImportSemaphoreFdInfoKHR{
	WImportSemaphoreFdInfoKHR(): VkImportSemaphoreFdInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
	}
};

struct WMemoryFdPropertiesKHR:public VkMemoryFdPropertiesKHR{
	WMemoryFdPropertiesKHR(): VkMemoryFdPropertiesKHR{}{
		sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
	}
};

struct WMemoryGetFdInfoKHR:public VkMemoryGetFdInfoKHR{
	WMemoryGetFdInfoKHR(): VkMemoryGetFdInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
	}
};

struct WDebugMarkerMarkerInfoEXT:public VkDebugMarkerMarkerInfoEXT{
	WDebugMarkerMarkerInfoEXT(): VkDebugMarkerMarkerInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
	}
	void setMarkerName(std::string const& markerName){
		this->pMarkerName = markerName.c_str();
	}
};

struct WDebugMarkerObjectNameInfoEXT:public VkDebugMarkerObjectNameInfoEXT{
	WDebugMarkerObjectNameInfoEXT(): VkDebugMarkerObjectNameInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
	}
	void setObjectName(std::string const& objectName){
		this->pObjectName = objectName.c_str();
	}
};

struct WDebugMarkerObjectTagInfoEXT:public VkDebugMarkerObjectTagInfoEXT{
	WDebugMarkerObjectTagInfoEXT(): VkDebugMarkerObjectTagInfoEXT{}{
		sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
	}
	void setTag(std::vector<uint8_t> const& tag){
		this->tagSize = tag.size();
		this->pTag = (void*)tag.data();
	}
};
#ifdef VK_USE_PLATFORM_WIN32_KHR


struct WWin32SurfaceCreateInfoKHR:public VkWin32SurfaceCreateInfoKHR{
	WWin32SurfaceCreateInfoKHR(): VkWin32SurfaceCreateInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
	}
};
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_ANDROID_KHR


struct WAndroidSurfaceCreateInfoKHR:public VkAndroidSurfaceCreateInfoKHR{
	WAndroidSurfaceCreateInfoKHR(): VkAndroidSurfaceCreateInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
	}
};
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/


struct WDisplaySurfaceCreateInfoKHR:public VkDisplaySurfaceCreateInfoKHR{
	WDisplaySurfaceCreateInfoKHR(): VkDisplaySurfaceCreateInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
	}
};

struct WDisplayPlaneCapabilitiesKHR:public VkDisplayPlaneCapabilitiesKHR{
	WDisplayPlaneCapabilitiesKHR(): VkDisplayPlaneCapabilitiesKHR{}{}
};

struct WDisplayModeCreateInfoKHR:public VkDisplayModeCreateInfoKHR{
	WDisplayModeCreateInfoKHR(): VkDisplayModeCreateInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
	}
};

struct WDisplayModePropertiesKHR:public VkDisplayModePropertiesKHR{
	WDisplayModePropertiesKHR(): VkDisplayModePropertiesKHR{}{}
};

struct WDisplayPlanePropertiesKHR:public VkDisplayPlanePropertiesKHR{
	WDisplayPlanePropertiesKHR(): VkDisplayPlanePropertiesKHR{}{}
};

struct WDisplayPropertiesKHR:public VkDisplayPropertiesKHR{
	WDisplayPropertiesKHR(): VkDisplayPropertiesKHR{}{}
	void setDisplayName(std::string const& displayName){
		this->displayName = displayName.c_str();
	}
};

struct WAcquireNextImageInfoKHR:public VkAcquireNextImageInfoKHR{
	WAcquireNextImageInfoKHR(): VkAcquireNextImageInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
	}
};

struct WDeviceGroupPresentCapabilitiesKHR:public VkDeviceGroupPresentCapabilitiesKHR{
	WDeviceGroupPresentCapabilitiesKHR(): VkDeviceGroupPresentCapabilitiesKHR{}{
		sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
	}
};

struct WPresentInfoKHR:public VkPresentInfoKHR{
	WPresentInfoKHR(): VkPresentInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
	}
	void setWaitSemaphores(std::vector<VkSemaphore> const& waitSemaphores){
		this->waitSemaphoreCount = waitSemaphores.size();
		this->pWaitSemaphores = waitSemaphores.data();
	}
	void setSwapchains(std::vector<VkSwapchainKHR> const& swapchains){
		this->swapchainCount = swapchains.size();
		this->pSwapchains = swapchains.data();
	}
	void setImageIndices(std::vector<uint32_t> const& imageIndices){
		rs_check( this->swapchainCount == imageIndices.size());
		this->pImageIndices = imageIndices.data();
	}
	void setResults(std::vector<VkResult> & results){
		rs_check( this->swapchainCount == results.size());
		this->pResults = results.data();
	}
};

struct WSwapchainCreateInfoKHR:public VkSwapchainCreateInfoKHR{
	WSwapchainCreateInfoKHR(): VkSwapchainCreateInfoKHR{}{
		sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
	}
	void setQueueFamilyIndices(std::vector<uint32_t> const& queueFamilyIndices){
		this->queueFamilyIndexCount = queueFamilyIndices.size();
		this->pQueueFamilyIndices = queueFamilyIndices.data();
	}
};

struct WDeviceMemoryOpaqueCaptureAddressInfo:public VkDeviceMemoryOpaqueCaptureAddressInfo{
	WDeviceMemoryOpaqueCaptureAddressInfo(): VkDeviceMemoryOpaqueCaptureAddressInfo{}{
		sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
	}
};

struct WBufferDeviceAddressInfo:public VkBufferDeviceAddressInfo{
	WBufferDeviceAddressInfo(): VkBufferDeviceAddressInfo{}{
		sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
	}
};

struct WSemaphoreSignalInfo:public VkSemaphoreSignalInfo{
	WSemaphoreSignalInfo(): VkSemaphoreSignalInfo{}{
		sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
	}
};

struct WSemaphoreWaitInfo:public VkSemaphoreWaitInfo{
	WSemaphoreWaitInfo(): VkSemaphoreWaitInfo{}{
		sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
	}
	void setSemaphores(std::vector<VkSemaphore> const& semaphores){
		this->semaphoreCount = semaphores.size();
		this->pSemaphores = semaphores.data();
	}
	void setValues(std::vector<uint64_t> const& values){
		rs_check( this->semaphoreCount == values.size());
		this->pValues = values.data();
	}
};

struct WSubpassEndInfo:public VkSubpassEndInfo{
	WSubpassEndInfo(): VkSubpassEndInfo{}{
		sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
	}
};

struct WSubpassBeginInfo:public VkSubpassBeginInfo{
	WSubpassBeginInfo(): VkSubpassBeginInfo{}{
		sType = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
	}
};

struct WRenderPassCreateInfo2:public VkRenderPassCreateInfo2{
	WRenderPassCreateInfo2(): VkRenderPassCreateInfo2{}{
		sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
	}
	void setAttachments(std::vector<WAttachmentDescription2> const& attachments){
		this->attachmentCount = attachments.size();
		this->pAttachments = attachments.data();
	}
	void setSubpasses(std::vector<WSubpassDescription2> const& subpasses){
		this->subpassCount = subpasses.size();
		this->pSubpasses = subpasses.data();
	}
	void setDependencies(std::vector<WSubpassDependency2> const& dependencies){
		this->dependencyCount = dependencies.size();
		this->pDependencies = dependencies.data();
	}
	void setCorrelatedViewMasks(std::vector<uint32_t> const& correlatedViewMasks){
		this->correlatedViewMaskCount = correlatedViewMasks.size();
		this->pCorrelatedViewMasks = correlatedViewMasks.data();
	}
};

struct WDescriptorSetLayoutSupport:public VkDescriptorSetLayoutSupport{
	WDescriptorSetLayoutSupport(): VkDescriptorSetLayoutSupport{}{
		sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
	}
};

struct WExternalSemaphoreProperties:public VkExternalSemaphoreProperties{
	WExternalSemaphoreProperties(): VkExternalSemaphoreProperties{}{
		sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
	}
};

struct WPhysicalDeviceExternalSemaphoreInfo:public VkPhysicalDeviceExternalSemaphoreInfo{
	WPhysicalDeviceExternalSemaphoreInfo(): VkPhysicalDeviceExternalSemaphoreInfo{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
	}
};

struct WExternalFenceProperties:public VkExternalFenceProperties{
	WExternalFenceProperties(): VkExternalFenceProperties{}{
		sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
	}
};

struct WPhysicalDeviceExternalFenceInfo:public VkPhysicalDeviceExternalFenceInfo{
	WPhysicalDeviceExternalFenceInfo(): VkPhysicalDeviceExternalFenceInfo{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
	}
};

struct WExternalBufferProperties:public VkExternalBufferProperties{
	WExternalBufferProperties(): VkExternalBufferProperties{}{
		sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
	}
};

struct WPhysicalDeviceExternalBufferInfo:public VkPhysicalDeviceExternalBufferInfo{
	WPhysicalDeviceExternalBufferInfo(): VkPhysicalDeviceExternalBufferInfo{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
	}
};

struct WDescriptorUpdateTemplateCreateInfo:public VkDescriptorUpdateTemplateCreateInfo{
	WDescriptorUpdateTemplateCreateInfo(): VkDescriptorUpdateTemplateCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
	}
	void setDescriptorUpdateEntries(std::vector<WDescriptorUpdateTemplateEntry> const& descriptorUpdateEntries){
		this->descriptorUpdateEntryCount = descriptorUpdateEntries.size();
		this->pDescriptorUpdateEntries = descriptorUpdateEntries.data();
	}
};

struct WSamplerYcbcrConversionCreateInfo:public VkSamplerYcbcrConversionCreateInfo{
	WSamplerYcbcrConversionCreateInfo(): VkSamplerYcbcrConversionCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
	}
};

struct WDeviceQueueInfo2:public VkDeviceQueueInfo2{
	WDeviceQueueInfo2(): VkDeviceQueueInfo2{}{
		sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
	}
};

struct WSparseImageFormatProperties2:public VkSparseImageFormatProperties2{
	WSparseImageFormatProperties2(): VkSparseImageFormatProperties2{}{
		sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
	}
};

struct WPhysicalDeviceSparseImageFormatInfo2:public VkPhysicalDeviceSparseImageFormatInfo2{
	WPhysicalDeviceSparseImageFormatInfo2(): VkPhysicalDeviceSparseImageFormatInfo2{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
	}
};

struct WPhysicalDeviceMemoryProperties2:public VkPhysicalDeviceMemoryProperties2{
	WPhysicalDeviceMemoryProperties2(): VkPhysicalDeviceMemoryProperties2{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
	}
};

struct WQueueFamilyProperties2:public VkQueueFamilyProperties2{
	WQueueFamilyProperties2(): VkQueueFamilyProperties2{}{
		sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
	}
};

struct WImageFormatProperties2:public VkImageFormatProperties2{
	WImageFormatProperties2(): VkImageFormatProperties2{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
	}
};

struct WPhysicalDeviceImageFormatInfo2:public VkPhysicalDeviceImageFormatInfo2{
	WPhysicalDeviceImageFormatInfo2(): VkPhysicalDeviceImageFormatInfo2{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
	}
};

struct WFormatProperties2:public VkFormatProperties2{
	WFormatProperties2(): VkFormatProperties2{}{
		sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
	}
};

struct WPhysicalDeviceProperties2:public VkPhysicalDeviceProperties2{
	WPhysicalDeviceProperties2(): VkPhysicalDeviceProperties2{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
	}
};

struct WPhysicalDeviceFeatures2:public VkPhysicalDeviceFeatures2{
	WPhysicalDeviceFeatures2(): VkPhysicalDeviceFeatures2{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
	}
};

struct WSparseImageMemoryRequirements2:public VkSparseImageMemoryRequirements2{
	WSparseImageMemoryRequirements2(): VkSparseImageMemoryRequirements2{}{
		sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
	}
};

struct WImageSparseMemoryRequirementsInfo2:public VkImageSparseMemoryRequirementsInfo2{
	WImageSparseMemoryRequirementsInfo2(): VkImageSparseMemoryRequirementsInfo2{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
	}
};

struct WBufferMemoryRequirementsInfo2:public VkBufferMemoryRequirementsInfo2{
	WBufferMemoryRequirementsInfo2(): VkBufferMemoryRequirementsInfo2{}{
		sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
	}
};

struct WMemoryRequirements2:public VkMemoryRequirements2{
	WMemoryRequirements2(): VkMemoryRequirements2{}{
		sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
	}
};

struct WImageMemoryRequirementsInfo2:public VkImageMemoryRequirementsInfo2{
	WImageMemoryRequirementsInfo2(): VkImageMemoryRequirementsInfo2{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
	}
};

struct WPhysicalDeviceGroupProperties:public VkPhysicalDeviceGroupProperties{
	WPhysicalDeviceGroupProperties(): VkPhysicalDeviceGroupProperties{}{
		sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
	}
};

struct WBindImageMemoryInfo:public VkBindImageMemoryInfo{
	WBindImageMemoryInfo(): VkBindImageMemoryInfo{}{
		sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
	}
};

struct WBindBufferMemoryInfo:public VkBindBufferMemoryInfo{
	WBindBufferMemoryInfo(): VkBindBufferMemoryInfo{}{
		sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
	}
};

struct WRenderPassBeginInfo:public VkRenderPassBeginInfo{
	WRenderPassBeginInfo(): VkRenderPassBeginInfo{}{
		sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
	}
	void setClearValues(std::vector<VkClearValue> const& clearValues){
		this->clearValueCount = clearValues.size();
		this->pClearValues = clearValues.data();
	}
};

struct WImageMemoryBarrier:public VkImageMemoryBarrier{
	WImageMemoryBarrier(): VkImageMemoryBarrier{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	}
};

struct WBufferMemoryBarrier:public VkBufferMemoryBarrier{
	WBufferMemoryBarrier(): VkBufferMemoryBarrier{}{
		sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
	}
};

struct WMemoryBarrier:public VkMemoryBarrier{
	WMemoryBarrier(): VkMemoryBarrier{}{
		sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
	}
};

struct WImageResolve:public VkImageResolve{
	WImageResolve(): VkImageResolve{}{}
};

struct WClearRect:public VkClearRect{
	WClearRect(): VkClearRect{}{}
};

struct WClearAttachment:public VkClearAttachment{
	WClearAttachment(): VkClearAttachment{}{}
};

struct WClearDepthStencilValue:public VkClearDepthStencilValue{
	WClearDepthStencilValue(): VkClearDepthStencilValue{}{}
};

struct WBufferImageCopy:public VkBufferImageCopy{
	WBufferImageCopy(): VkBufferImageCopy{}{}
};

struct WImageBlit:public VkImageBlit{
	WImageBlit(): VkImageBlit{}{}
};

struct WImageCopy:public VkImageCopy{
	WImageCopy(): VkImageCopy{}{}
};

struct WBufferCopy:public VkBufferCopy{
	WBufferCopy(): VkBufferCopy{}{}
};

struct WViewport:public VkViewport{
	WViewport(): VkViewport{}{}
};

struct WCommandBufferBeginInfo:public VkCommandBufferBeginInfo{
	WCommandBufferBeginInfo(): VkCommandBufferBeginInfo{}{
		sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
	}
};

struct WCommandBufferAllocateInfo:public VkCommandBufferAllocateInfo{
	WCommandBufferAllocateInfo(): VkCommandBufferAllocateInfo{}{
		sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	}
};

struct WCommandPoolCreateInfo:public VkCommandPoolCreateInfo{
	WCommandPoolCreateInfo(): VkCommandPoolCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
	}
};

struct WRenderPassCreateInfo:public VkRenderPassCreateInfo{
	WRenderPassCreateInfo(): VkRenderPassCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
	}
	void setAttachments(std::vector<WAttachmentDescription> const& attachments){
		this->attachmentCount = attachments.size();
		this->pAttachments = attachments.data();
	}
	void setSubpasses(std::vector<WSubpassDescription> const& subpasses){
		this->subpassCount = subpasses.size();
		this->pSubpasses = subpasses.data();
	}
	void setDependencies(std::vector<WSubpassDependency> const& dependencies){
		this->dependencyCount = dependencies.size();
		this->pDependencies = dependencies.data();
	}
};

struct WFramebufferCreateInfo:public VkFramebufferCreateInfo{
	WFramebufferCreateInfo(): VkFramebufferCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
	}
	void setAttachments(std::vector<VkImageView> const& attachments){
		this->attachmentCount = attachments.size();
		this->pAttachments = attachments.data();
	}
};

struct WCopyDescriptorSet:public VkCopyDescriptorSet{
	WCopyDescriptorSet(): VkCopyDescriptorSet{}{
		sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
	}
};

struct WWriteDescriptorSet:public VkWriteDescriptorSet{
	WWriteDescriptorSet(): VkWriteDescriptorSet{}{
		sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
	}
	void setImageInfo(std::vector<WDescriptorImageInfo> const& imageInfo){
		this->descriptorCount = imageInfo.size();
		this->pImageInfo = imageInfo.data();
	}
	void setBufferInfo(std::vector<WDescriptorBufferInfo> const& bufferInfo){
		rs_check( this->descriptorCount == bufferInfo.size());
		this->pBufferInfo = bufferInfo.data();
	}
	void setTexelBufferView(std::vector<VkBufferView> const& texelBufferView){
		rs_check( this->descriptorCount == texelBufferView.size());
		this->pTexelBufferView = texelBufferView.data();
	}
};

struct WDescriptorSetAllocateInfo:public VkDescriptorSetAllocateInfo{
	WDescriptorSetAllocateInfo(): VkDescriptorSetAllocateInfo{}{
		sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
	}
	void setSetLayouts(std::vector<VkDescriptorSetLayout> const& setLayouts){
		this->descriptorSetCount = setLayouts.size();
		this->pSetLayouts = setLayouts.data();
	}
};

struct WDescriptorPoolCreateInfo:public VkDescriptorPoolCreateInfo{
	WDescriptorPoolCreateInfo(): VkDescriptorPoolCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
	}
	void setPoolSizes(std::vector<WDescriptorPoolSize> const& poolSizes){
		this->poolSizeCount = poolSizes.size();
		this->pPoolSizes = poolSizes.data();
	}
};

struct WDescriptorSetLayoutCreateInfo:public VkDescriptorSetLayoutCreateInfo{
	WDescriptorSetLayoutCreateInfo(): VkDescriptorSetLayoutCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
	}
	void setBindings(std::vector<WDescriptorSetLayoutBinding> const& bindings){
		this->bindingCount = bindings.size();
		this->pBindings = bindings.data();
	}
};

struct WSamplerCreateInfo:public VkSamplerCreateInfo{
	WSamplerCreateInfo(): VkSamplerCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
	}
};

struct WPipelineLayoutCreateInfo:public VkPipelineLayoutCreateInfo{
	WPipelineLayoutCreateInfo(): VkPipelineLayoutCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
	}
	void setSetLayouts(std::vector<VkDescriptorSetLayout> const& setLayouts){
		this->setLayoutCount = setLayouts.size();
		this->pSetLayouts = setLayouts.data();
	}
	void setPushConstantRanges(std::vector<WPushConstantRange> const& pushConstantRanges){
		this->pushConstantRangeCount = pushConstantRanges.size();
		this->pPushConstantRanges = pushConstantRanges.data();
	}
};

struct WComputePipelineCreateInfo:public VkComputePipelineCreateInfo{
	WComputePipelineCreateInfo(): VkComputePipelineCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
	}
};

struct WGraphicsPipelineCreateInfo:public VkGraphicsPipelineCreateInfo{
	WGraphicsPipelineCreateInfo(): VkGraphicsPipelineCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
	}
	void setStages(std::vector<WPipelineShaderStageCreateInfo> const& stages){
		this->stageCount = stages.size();
		this->pStages = stages.data();
	}
};

struct WPipelineCacheCreateInfo:public VkPipelineCacheCreateInfo{
	WPipelineCacheCreateInfo(): VkPipelineCacheCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
	}
	void setInitialData(std::vector<uint8_t> const& initialData){
		this->initialDataSize = initialData.size();
		this->pInitialData = (void*)initialData.data();
	}
};

struct WShaderModuleCreateInfo:public VkShaderModuleCreateInfo{
	WShaderModuleCreateInfo(): VkShaderModuleCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	}
};

struct WImageViewCreateInfo:public VkImageViewCreateInfo{
	WImageViewCreateInfo(): VkImageViewCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	}
};

struct WSubresourceLayout:public VkSubresourceLayout{
	WSubresourceLayout(): VkSubresourceLayout{}{}
};

struct WImageSubresource:public VkImageSubresource{
	WImageSubresource(): VkImageSubresource{}{}
};

struct WImageCreateInfo:public VkImageCreateInfo{
	WImageCreateInfo(): VkImageCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
	}
	void setQueueFamilyIndices(std::vector<uint32_t> const& queueFamilyIndices){
		this->queueFamilyIndexCount = queueFamilyIndices.size();
		this->pQueueFamilyIndices = queueFamilyIndices.data();
	}
};

struct WBufferViewCreateInfo:public VkBufferViewCreateInfo{
	WBufferViewCreateInfo(): VkBufferViewCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
	}
};

struct WBufferCreateInfo:public VkBufferCreateInfo{
	WBufferCreateInfo(): VkBufferCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	}
	void setQueueFamilyIndices(std::vector<uint32_t> const& queueFamilyIndices){
		this->queueFamilyIndexCount = queueFamilyIndices.size();
		this->pQueueFamilyIndices = queueFamilyIndices.data();
	}
};

struct WQueryPoolCreateInfo:public VkQueryPoolCreateInfo{
	WQueryPoolCreateInfo(): VkQueryPoolCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
	}
};

struct WEventCreateInfo:public VkEventCreateInfo{
	WEventCreateInfo(): VkEventCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
	}
};

struct WSemaphoreCreateInfo:public VkSemaphoreCreateInfo{
	WSemaphoreCreateInfo(): VkSemaphoreCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	}
};

struct WFenceCreateInfo:public VkFenceCreateInfo{
	WFenceCreateInfo(): VkFenceCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	}
};

struct WBindSparseInfo:public VkBindSparseInfo{
	WBindSparseInfo(): VkBindSparseInfo{}{
		sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
	}
	void setWaitSemaphores(std::vector<VkSemaphore> const& waitSemaphores){
		this->waitSemaphoreCount = waitSemaphores.size();
		this->pWaitSemaphores = waitSemaphores.data();
	}
	void setBufferBinds(std::vector<WSparseBufferMemoryBindInfo> const& bufferBinds){
		this->bufferBindCount = bufferBinds.size();
		this->pBufferBinds = bufferBinds.data();
	}
	void setImageOpaqueBinds(std::vector<WSparseImageOpaqueMemoryBindInfo> const& imageOpaqueBinds){
		this->imageOpaqueBindCount = imageOpaqueBinds.size();
		this->pImageOpaqueBinds = imageOpaqueBinds.data();
	}
	void setImageBinds(std::vector<WSparseImageMemoryBindInfo> const& imageBinds){
		this->imageBindCount = imageBinds.size();
		this->pImageBinds = imageBinds.data();
	}
	void setSignalSemaphores(std::vector<VkSemaphore> const& signalSemaphores){
		this->signalSemaphoreCount = signalSemaphores.size();
		this->pSignalSemaphores = signalSemaphores.data();
	}
};

struct WMappedMemoryRange:public VkMappedMemoryRange{
	WMappedMemoryRange(): VkMappedMemoryRange{}{
		sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
	}
};

struct WMemoryAllocateInfo:public VkMemoryAllocateInfo{
	WMemoryAllocateInfo(): VkMemoryAllocateInfo{}{
		sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	}
};

struct WSubmitInfo:public VkSubmitInfo{
	WSubmitInfo(): VkSubmitInfo{}{
		sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
	}
	void setWaitSemaphores(std::vector<VkSemaphore> const& waitSemaphores){
		this->waitSemaphoreCount = waitSemaphores.size();
		this->pWaitSemaphores = waitSemaphores.data();
	}
	void setWaitDstStageMask(std::vector<VkPipelineStageFlags> const& waitDstStageMask){
		rs_check( this->waitSemaphoreCount == waitDstStageMask.size());
		this->pWaitDstStageMask = waitDstStageMask.data();
	}
	void setCommandBuffers(std::vector<VkCommandBuffer> const& commandBuffers){
		this->commandBufferCount = commandBuffers.size();
		this->pCommandBuffers = commandBuffers.data();
	}
	void setSignalSemaphores(std::vector<VkSemaphore> const& signalSemaphores){
		this->signalSemaphoreCount = signalSemaphores.size();
		this->pSignalSemaphores = signalSemaphores.data();
	}
};

struct WLayerProperties:public VkLayerProperties{
	WLayerProperties(): VkLayerProperties{}{}
};

struct WExtensionProperties:public VkExtensionProperties{
	WExtensionProperties(): VkExtensionProperties{}{}
};

struct WDeviceCreateInfo:public VkDeviceCreateInfo{
	WDeviceCreateInfo(): VkDeviceCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
	}
	void setQueueCreateInfos(std::vector<WDeviceQueueCreateInfo> const& queueCreateInfos){
		this->queueCreateInfoCount = queueCreateInfos.size();
		this->pQueueCreateInfos = queueCreateInfos.data();
	}
	void setEnabledLayerNames(std::vector<char const*> const& enabledLayerNames){
		this->enabledLayerCount = enabledLayerNames.size();
		this->ppEnabledLayerNames = enabledLayerNames.data();
	}
	void setEnabledExtensionNames(std::vector<char const*> const& enabledExtensionNames){
		this->enabledExtensionCount = enabledExtensionNames.size();
		this->ppEnabledExtensionNames = enabledExtensionNames.data();
	}
};

struct WAllocationCallbacks:public VkAllocationCallbacks{
	WAllocationCallbacks(): VkAllocationCallbacks{}{}
};

struct WInstanceCreateInfo:public VkInstanceCreateInfo{
	WInstanceCreateInfo(): VkInstanceCreateInfo{}{
		sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
	}
	void setEnabledLayerNames(std::vector<char const*> const& enabledLayerNames){
		this->enabledLayerCount = enabledLayerNames.size();
		this->ppEnabledLayerNames = enabledLayerNames.data();
	}
	void setEnabledExtensionNames(std::vector<char const*> const& enabledExtensionNames){
		this->enabledExtensionCount = enabledExtensionNames.size();
		this->ppEnabledExtensionNames = enabledExtensionNames.data();
	}
};



struct WInstance: public VkInstDispatchTable{
	
	WInstance():VkInstDispatchTable{}
	{}

	void destroyInstance( ){
		rs_check(this->vkDestroyInstance!=nullptr);
		this->vkDestroyInstance(handle, nullptr);
	}

	VkResult enumeratePhysicalDevices(  uint32_t * pPhysicalDeviceCount, VkPhysicalDevice * pPhysicalDevices){
		rs_check(this->vkEnumeratePhysicalDevices!=nullptr);
		return this->vkEnumeratePhysicalDevices(handle, pPhysicalDeviceCount, pPhysicalDevices);
	}
#ifdef VK_USE_PLATFORM_ANDROID_KHR
	VkResult createAndroidSurfaceKHR(  VkAndroidSurfaceCreateInfoKHR const* pCreateInfo, VkSurfaceKHR * pSurface){
		rs_check(this->vkCreateAndroidSurfaceKHR!=nullptr);
		return this->vkCreateAndroidSurfaceKHR(handle, pCreateInfo, nullptr, pSurface);
	}
#endif

	VkResult createDisplayPlaneSurfaceKHR(  VkDisplaySurfaceCreateInfoKHR const* pCreateInfo, VkSurfaceKHR * pSurface){
		rs_check(this->vkCreateDisplayPlaneSurfaceKHR!=nullptr);
		return this->vkCreateDisplayPlaneSurfaceKHR(handle, pCreateInfo, nullptr, pSurface);
	}

	void destroySurfaceKHR(  VkSurfaceKHR  surface){
		rs_check(this->vkDestroySurfaceKHR!=nullptr);
		this->vkDestroySurfaceKHR(handle, surface, nullptr);
	}
#ifdef VK_USE_PLATFORM_WIN32_KHR
	VkResult createWin32SurfaceKHR(  VkWin32SurfaceCreateInfoKHR const* pCreateInfo, VkSurfaceKHR * pSurface){
		rs_check(this->vkCreateWin32SurfaceKHR!=nullptr);
		return this->vkCreateWin32SurfaceKHR(handle, pCreateInfo, nullptr, pSurface);
	}
#endif

	VkResult createDebugReportCallbackEXT(  VkDebugReportCallbackCreateInfoEXT const* pCreateInfo, VkDebugReportCallbackEXT * pCallback){
		rs_check(this->vkCreateDebugReportCallbackEXT!=nullptr);
		return this->vkCreateDebugReportCallbackEXT(handle, pCreateInfo, nullptr, pCallback);
	}

	void destroyDebugReportCallbackEXT(  VkDebugReportCallbackEXT  callback){
		rs_check(this->vkDestroyDebugReportCallbackEXT!=nullptr);
		this->vkDestroyDebugReportCallbackEXT(handle, callback, nullptr);
	}

	void debugReportMessageEXT(  VkDebugReportFlagsEXT  flags, VkDebugReportObjectTypeEXT  objectType, uint64_t  object, size_t  location, int32_t  messageCode, char const* pLayerPrefix, char const* pMessage){
		rs_check(this->vkDebugReportMessageEXT!=nullptr);
		this->vkDebugReportMessageEXT(handle, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
	}

	VkResult enumeratePhysicalDeviceGroups(  uint32_t * pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties){
		rs_check(this->vkEnumeratePhysicalDeviceGroups!=nullptr);
		return this->vkEnumeratePhysicalDeviceGroups(handle, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
	}

	VkResult enumeratePhysicalDeviceGroupsKHR(  uint32_t * pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties){
		rs_check(this->vkEnumeratePhysicalDeviceGroupsKHR!=nullptr);
		return this->vkEnumeratePhysicalDeviceGroupsKHR(handle, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
	}
};

struct WPhysicalDevice: public VkDevDispatchTable{
	
	WPhysicalDevice():VkDevDispatchTable{}
	{}

	void getPhysicalDeviceProperties(  VkPhysicalDeviceProperties * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceProperties(physicalHandle, pProperties);
	}

	void getPhysicalDeviceQueueFamilyProperties(  uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties * pQueueFamilyProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties(physicalHandle, pQueueFamilyPropertyCount, pQueueFamilyProperties);
	}

	void getPhysicalDeviceMemoryProperties(  VkPhysicalDeviceMemoryProperties * pMemoryProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties(physicalHandle, pMemoryProperties);
	}

	void getPhysicalDeviceFeatures(  VkPhysicalDeviceFeatures * pFeatures){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFeatures!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFeatures(physicalHandle, pFeatures);
	}

	void getPhysicalDeviceFormatProperties(  VkFormat  format, VkFormatProperties * pFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFormatProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFormatProperties(physicalHandle, format, pFormatProperties);
	}

	VkResult getPhysicalDeviceImageFormatProperties(  VkFormat  format, VkImageType  type, VkImageTiling  tiling, VkImageUsageFlags  usage, VkImageCreateFlags  flags, VkImageFormatProperties * pImageFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties(physicalHandle, format, type, tiling, usage, flags, pImageFormatProperties);
	}

	VkResult createDevice(  VkDeviceCreateInfo const* pCreateInfo, VkDevice * pDevice){
		rs_check(GInstanceCommands()->vkCreateDevice!=nullptr);
		return GInstanceCommands()->vkCreateDevice(physicalHandle, pCreateInfo, nullptr, pDevice);
	}

	VkResult enumerateDeviceLayerProperties(  uint32_t * pPropertyCount, VkLayerProperties * pProperties){
		rs_check(GInstanceCommands()->vkEnumerateDeviceLayerProperties!=nullptr);
		return GInstanceCommands()->vkEnumerateDeviceLayerProperties(physicalHandle, pPropertyCount, pProperties);
	}

	VkResult enumerateDeviceExtensionProperties(  char const* pLayerName, uint32_t * pPropertyCount, VkExtensionProperties * pProperties){
		rs_check(GInstanceCommands()->vkEnumerateDeviceExtensionProperties!=nullptr);
		return GInstanceCommands()->vkEnumerateDeviceExtensionProperties(physicalHandle, pLayerName, pPropertyCount, pProperties);
	}

	void getPhysicalDeviceSparseImageFormatProperties(  VkFormat  format, VkImageType  type, VkSampleCountFlagBits  samples, VkImageUsageFlags  usage, VkImageTiling  tiling, uint32_t * pPropertyCount, VkSparseImageFormatProperties * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties(physicalHandle, format, type, samples, usage, tiling, pPropertyCount, pProperties);
	}

	VkResult getPhysicalDeviceDisplayPropertiesKHR(  uint32_t * pPropertyCount, VkDisplayPropertiesKHR * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceDisplayPropertiesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceDisplayPropertiesKHR(physicalHandle, pPropertyCount, pProperties);
	}

	VkResult getPhysicalDeviceDisplayPlanePropertiesKHR(  uint32_t * pPropertyCount, VkDisplayPlanePropertiesKHR * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalHandle, pPropertyCount, pProperties);
	}

	VkResult getDisplayPlaneSupportedDisplaysKHR(  uint32_t  planeIndex, uint32_t * pDisplayCount, VkDisplayKHR * pDisplays){
		rs_check(GInstanceCommands()->vkGetDisplayPlaneSupportedDisplaysKHR!=nullptr);
		return GInstanceCommands()->vkGetDisplayPlaneSupportedDisplaysKHR(physicalHandle, planeIndex, pDisplayCount, pDisplays);
	}

	VkResult getDisplayModePropertiesKHR(  VkDisplayKHR  display, uint32_t * pPropertyCount, VkDisplayModePropertiesKHR * pProperties){
		rs_check(GInstanceCommands()->vkGetDisplayModePropertiesKHR!=nullptr);
		return GInstanceCommands()->vkGetDisplayModePropertiesKHR(physicalHandle, display, pPropertyCount, pProperties);
	}

	VkResult createDisplayModeKHR(  VkDisplayKHR  display, VkDisplayModeCreateInfoKHR const* pCreateInfo, VkDisplayModeKHR * pMode){
		rs_check(GInstanceCommands()->vkCreateDisplayModeKHR!=nullptr);
		return GInstanceCommands()->vkCreateDisplayModeKHR(physicalHandle, display, pCreateInfo, nullptr, pMode);
	}

	VkResult getDisplayPlaneCapabilitiesKHR(  VkDisplayModeKHR  mode, uint32_t  planeIndex, VkDisplayPlaneCapabilitiesKHR * pCapabilities){
		rs_check(GInstanceCommands()->vkGetDisplayPlaneCapabilitiesKHR!=nullptr);
		return GInstanceCommands()->vkGetDisplayPlaneCapabilitiesKHR(physicalHandle, mode, planeIndex, pCapabilities);
	}

	VkResult getPhysicalDeviceSurfaceSupportKHR(  uint32_t  queueFamilyIndex, VkSurfaceKHR  surface, VkBool32 * pSupported){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfaceSupportKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfaceSupportKHR(physicalHandle, queueFamilyIndex, surface, pSupported);
	}

	VkResult getPhysicalDeviceSurfaceCapabilitiesKHR(  VkSurfaceKHR  surface, VkSurfaceCapabilitiesKHR * pSurfaceCapabilities){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalHandle, surface, pSurfaceCapabilities);
	}

	VkResult getPhysicalDeviceSurfaceFormatsKHR(  VkSurfaceKHR  surface, uint32_t * pSurfaceFormatCount, VkSurfaceFormatKHR * pSurfaceFormats){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfaceFormatsKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfaceFormatsKHR(physicalHandle, surface, pSurfaceFormatCount, pSurfaceFormats);
	}

	VkResult getPhysicalDeviceSurfacePresentModesKHR(  VkSurfaceKHR  surface, uint32_t * pPresentModeCount, VkPresentModeKHR * pPresentModes){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfacePresentModesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfacePresentModesKHR(physicalHandle, surface, pPresentModeCount, pPresentModes);
	}
#ifdef VK_USE_PLATFORM_WIN32_KHR
	VkBool32 getPhysicalDeviceWin32PresentationSupportKHR(  uint32_t  queueFamilyIndex){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceWin32PresentationSupportKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalHandle, queueFamilyIndex);
	}
#endif

	void getPhysicalDeviceFeatures2(  VkPhysicalDeviceFeatures2 * pFeatures){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFeatures2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFeatures2(physicalHandle, pFeatures);
	}

	void getPhysicalDeviceFeatures2KHR(  VkPhysicalDeviceFeatures2 * pFeatures){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFeatures2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFeatures2KHR(physicalHandle, pFeatures);
	}

	void getPhysicalDeviceProperties2(  VkPhysicalDeviceProperties2 * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceProperties2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceProperties2(physicalHandle, pProperties);
	}

	void getPhysicalDeviceProperties2KHR(  VkPhysicalDeviceProperties2 * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceProperties2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceProperties2KHR(physicalHandle, pProperties);
	}

	void getPhysicalDeviceFormatProperties2(  VkFormat  format, VkFormatProperties2 * pFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFormatProperties2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFormatProperties2(physicalHandle, format, pFormatProperties);
	}

	void getPhysicalDeviceFormatProperties2KHR(  VkFormat  format, VkFormatProperties2 * pFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFormatProperties2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceFormatProperties2KHR(physicalHandle, format, pFormatProperties);
	}

	VkResult getPhysicalDeviceImageFormatProperties2(  VkPhysicalDeviceImageFormatInfo2 const* pImageFormatInfo, VkImageFormatProperties2 * pImageFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties2!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties2(physicalHandle, pImageFormatInfo, pImageFormatProperties);
	}

	VkResult getPhysicalDeviceImageFormatProperties2KHR(  VkPhysicalDeviceImageFormatInfo2 const* pImageFormatInfo, VkImageFormatProperties2 * pImageFormatProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties2KHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceImageFormatProperties2KHR(physicalHandle, pImageFormatInfo, pImageFormatProperties);
	}

	void getPhysicalDeviceQueueFamilyProperties2(  uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties2 * pQueueFamilyProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties2(physicalHandle, pQueueFamilyPropertyCount, pQueueFamilyProperties);
	}

	void getPhysicalDeviceQueueFamilyProperties2KHR(  uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties2 * pQueueFamilyProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalHandle, pQueueFamilyPropertyCount, pQueueFamilyProperties);
	}

	void getPhysicalDeviceMemoryProperties2(  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties2(physicalHandle, pMemoryProperties);
	}

	void getPhysicalDeviceMemoryProperties2KHR(  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceMemoryProperties2KHR(physicalHandle, pMemoryProperties);
	}

	void getPhysicalDeviceSparseImageFormatProperties2(  VkPhysicalDeviceSparseImageFormatInfo2 const* pFormatInfo, uint32_t * pPropertyCount, VkSparseImageFormatProperties2 * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties2!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties2(physicalHandle, pFormatInfo, pPropertyCount, pProperties);
	}

	void getPhysicalDeviceSparseImageFormatProperties2KHR(  VkPhysicalDeviceSparseImageFormatInfo2 const* pFormatInfo, uint32_t * pPropertyCount, VkSparseImageFormatProperties2 * pProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalHandle, pFormatInfo, pPropertyCount, pProperties);
	}

	void getPhysicalDeviceExternalBufferProperties(  VkPhysicalDeviceExternalBufferInfo const* pExternalBufferInfo, VkExternalBufferProperties * pExternalBufferProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalBufferProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalBufferProperties(physicalHandle, pExternalBufferInfo, pExternalBufferProperties);
	}

	void getPhysicalDeviceExternalBufferPropertiesKHR(  VkPhysicalDeviceExternalBufferInfo const* pExternalBufferInfo, VkExternalBufferProperties * pExternalBufferProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalBufferPropertiesKHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalHandle, pExternalBufferInfo, pExternalBufferProperties);
	}

	void getPhysicalDeviceExternalSemaphoreProperties(  VkPhysicalDeviceExternalSemaphoreInfo const* pExternalSemaphoreInfo, VkExternalSemaphoreProperties * pExternalSemaphoreProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalSemaphoreProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalSemaphoreProperties(physicalHandle, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
	}

	void getPhysicalDeviceExternalSemaphorePropertiesKHR(  VkPhysicalDeviceExternalSemaphoreInfo const* pExternalSemaphoreInfo, VkExternalSemaphoreProperties * pExternalSemaphoreProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalHandle, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
	}

	void getPhysicalDeviceExternalFenceProperties(  VkPhysicalDeviceExternalFenceInfo const* pExternalFenceInfo, VkExternalFenceProperties * pExternalFenceProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalFenceProperties!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalFenceProperties(physicalHandle, pExternalFenceInfo, pExternalFenceProperties);
	}

	void getPhysicalDeviceExternalFencePropertiesKHR(  VkPhysicalDeviceExternalFenceInfo const* pExternalFenceInfo, VkExternalFenceProperties * pExternalFenceProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceExternalFencePropertiesKHR!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalHandle, pExternalFenceInfo, pExternalFenceProperties);
	}

	VkResult getPhysicalDevicePresentRectanglesKHR(  VkSurfaceKHR  surface, uint32_t * pRectCount, VkRect2D * pRects){
		rs_check(GInstanceCommands()->vkGetPhysicalDevicePresentRectanglesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDevicePresentRectanglesKHR(physicalHandle, surface, pRectCount, pRects);
	}

	void getPhysicalDeviceMultisamplePropertiesEXT(  VkSampleCountFlagBits  samples, VkMultisamplePropertiesEXT * pMultisampleProperties){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceMultisamplePropertiesEXT!=nullptr);
		GInstanceCommands()->vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalHandle, samples, pMultisampleProperties);
	}

	VkResult getPhysicalDeviceSurfaceCapabilities2KHR(  VkPhysicalDeviceSurfaceInfo2KHR const* pSurfaceInfo, VkSurfaceCapabilities2KHR * pSurfaceCapabilities){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfaceCapabilities2KHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalHandle, pSurfaceInfo, pSurfaceCapabilities);
	}

	VkResult getPhysicalDeviceSurfaceFormats2KHR(  VkPhysicalDeviceSurfaceInfo2KHR const* pSurfaceInfo, uint32_t * pSurfaceFormatCount, VkSurfaceFormat2KHR * pSurfaceFormats){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceSurfaceFormats2KHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceSurfaceFormats2KHR(physicalHandle, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
	}

	VkResult getPhysicalDeviceFragmentShadingRatesKHR(  uint32_t * pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR * pFragmentShadingRates){
		rs_check(GInstanceCommands()->vkGetPhysicalDeviceFragmentShadingRatesKHR!=nullptr);
		return GInstanceCommands()->vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalHandle, pFragmentShadingRateCount, pFragmentShadingRates);
	}
};

struct WDevice: public WPhysicalDevice{
	
	WDevice():WPhysicalDevice{}
	{}

	PFN_vkVoidFunction getDeviceProcAddr(  char const* pName){
		rs_check(this->vkGetDeviceProcAddr!=nullptr);
		return this->vkGetDeviceProcAddr(handle, pName);
	}

	void destroyDevice( ){
		rs_check(this->vkDestroyDevice!=nullptr);
		this->vkDestroyDevice(handle, nullptr);
	}

	void getDeviceQueue(  uint32_t  queueFamilyIndex, uint32_t  queueIndex, VkQueue * pQueue){
		rs_check(this->vkGetDeviceQueue!=nullptr);
		this->vkGetDeviceQueue(handle, queueFamilyIndex, queueIndex, pQueue);
	}

	VkResult deviceWaitIdle( ){
		rs_check(this->vkDeviceWaitIdle!=nullptr);
		return this->vkDeviceWaitIdle(handle);
	}

	VkResult allocateMemory(  VkMemoryAllocateInfo const* pAllocateInfo, VkDeviceMemory * pMemory){
		rs_check(this->vkAllocateMemory!=nullptr);
		return this->vkAllocateMemory(handle, pAllocateInfo, nullptr, pMemory);
	}

	void freeMemory(  VkDeviceMemory  memory){
		rs_check(this->vkFreeMemory!=nullptr);
		this->vkFreeMemory(handle, memory, nullptr);
	}

	VkResult mapMemory(  VkDeviceMemory  memory, VkDeviceSize  offset, VkDeviceSize  size, VkMemoryMapFlags  flags, void ** ppData){
		rs_check(this->vkMapMemory!=nullptr);
		return this->vkMapMemory(handle, memory, offset, size, flags, ppData);
	}

	void unmapMemory(  VkDeviceMemory  memory){
		rs_check(this->vkUnmapMemory!=nullptr);
		this->vkUnmapMemory(handle, memory);
	}

	VkResult flushMappedMemoryRanges(  uint32_t  memoryRangeCount, VkMappedMemoryRange const* pMemoryRanges){
		rs_check(this->vkFlushMappedMemoryRanges!=nullptr);
		return this->vkFlushMappedMemoryRanges(handle, memoryRangeCount, pMemoryRanges);
	}

	VkResult invalidateMappedMemoryRanges(  uint32_t  memoryRangeCount, VkMappedMemoryRange const* pMemoryRanges){
		rs_check(this->vkInvalidateMappedMemoryRanges!=nullptr);
		return this->vkInvalidateMappedMemoryRanges(handle, memoryRangeCount, pMemoryRanges);
	}

	void getDeviceMemoryCommitment(  VkDeviceMemory  memory, VkDeviceSize * pCommittedMemoryInBytes){
		rs_check(this->vkGetDeviceMemoryCommitment!=nullptr);
		this->vkGetDeviceMemoryCommitment(handle, memory, pCommittedMemoryInBytes);
	}

	void getBufferMemoryRequirements(  VkBuffer  buffer, VkMemoryRequirements * pMemoryRequirements){
		rs_check(this->vkGetBufferMemoryRequirements!=nullptr);
		this->vkGetBufferMemoryRequirements(handle, buffer, pMemoryRequirements);
	}

	VkResult bindBufferMemory(  VkBuffer  buffer, VkDeviceMemory  memory, VkDeviceSize  memoryOffset){
		rs_check(this->vkBindBufferMemory!=nullptr);
		return this->vkBindBufferMemory(handle, buffer, memory, memoryOffset);
	}

	void getImageMemoryRequirements(  VkImage  image, VkMemoryRequirements * pMemoryRequirements){
		rs_check(this->vkGetImageMemoryRequirements!=nullptr);
		this->vkGetImageMemoryRequirements(handle, image, pMemoryRequirements);
	}

	VkResult bindImageMemory(  VkImage  image, VkDeviceMemory  memory, VkDeviceSize  memoryOffset){
		rs_check(this->vkBindImageMemory!=nullptr);
		return this->vkBindImageMemory(handle, image, memory, memoryOffset);
	}

	void getImageSparseMemoryRequirements(  VkImage  image, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements * pSparseMemoryRequirements){
		rs_check(this->vkGetImageSparseMemoryRequirements!=nullptr);
		this->vkGetImageSparseMemoryRequirements(handle, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
	}

	VkResult createFence(  VkFenceCreateInfo const* pCreateInfo, VkFence * pFence){
		rs_check(this->vkCreateFence!=nullptr);
		return this->vkCreateFence(handle, pCreateInfo, nullptr, pFence);
	}

	void destroyFence(  VkFence  fence){
		rs_check(this->vkDestroyFence!=nullptr);
		this->vkDestroyFence(handle, fence, nullptr);
	}

	VkResult resetFences(  uint32_t  fenceCount, VkFence const* pFences){
		rs_check(this->vkResetFences!=nullptr);
		return this->vkResetFences(handle, fenceCount, pFences);
	}

	VkResult getFenceStatus(  VkFence  fence){
		rs_check(this->vkGetFenceStatus!=nullptr);
		return this->vkGetFenceStatus(handle, fence);
	}

	VkResult waitForFences(  uint32_t  fenceCount, VkFence const* pFences, VkBool32  waitAll, uint64_t  timeout){
		rs_check(this->vkWaitForFences!=nullptr);
		return this->vkWaitForFences(handle, fenceCount, pFences, waitAll, timeout);
	}

	VkResult createSemaphore(  VkSemaphoreCreateInfo const* pCreateInfo, VkSemaphore * pSemaphore){
		rs_check(this->vkCreateSemaphore!=nullptr);
		return this->vkCreateSemaphore(handle, pCreateInfo, nullptr, pSemaphore);
	}

	void destroySemaphore(  VkSemaphore  semaphore){
		rs_check(this->vkDestroySemaphore!=nullptr);
		this->vkDestroySemaphore(handle, semaphore, nullptr);
	}

	VkResult createEvent(  VkEventCreateInfo const* pCreateInfo, VkEvent * pEvent){
		rs_check(this->vkCreateEvent!=nullptr);
		return this->vkCreateEvent(handle, pCreateInfo, nullptr, pEvent);
	}

	void destroyEvent(  VkEvent  event){
		rs_check(this->vkDestroyEvent!=nullptr);
		this->vkDestroyEvent(handle, event, nullptr);
	}

	VkResult getEventStatus(  VkEvent  event){
		rs_check(this->vkGetEventStatus!=nullptr);
		return this->vkGetEventStatus(handle, event);
	}

	VkResult setEvent(  VkEvent  event){
		rs_check(this->vkSetEvent!=nullptr);
		return this->vkSetEvent(handle, event);
	}

	VkResult resetEvent(  VkEvent  event){
		rs_check(this->vkResetEvent!=nullptr);
		return this->vkResetEvent(handle, event);
	}

	VkResult createQueryPool(  VkQueryPoolCreateInfo const* pCreateInfo, VkQueryPool * pQueryPool){
		rs_check(this->vkCreateQueryPool!=nullptr);
		return this->vkCreateQueryPool(handle, pCreateInfo, nullptr, pQueryPool);
	}

	void destroyQueryPool(  VkQueryPool  queryPool){
		rs_check(this->vkDestroyQueryPool!=nullptr);
		this->vkDestroyQueryPool(handle, queryPool, nullptr);
	}

	VkResult getQueryPoolResults(  VkQueryPool  queryPool, uint32_t  firstQuery, uint32_t  queryCount, size_t  dataSize, void * pData, VkDeviceSize  stride, VkQueryResultFlags  flags){
		rs_check(this->vkGetQueryPoolResults!=nullptr);
		return this->vkGetQueryPoolResults(handle, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
	}

	void resetQueryPool(  VkQueryPool  queryPool, uint32_t  firstQuery, uint32_t  queryCount){
		rs_check(this->vkResetQueryPool!=nullptr);
		this->vkResetQueryPool(handle, queryPool, firstQuery, queryCount);
	}

	VkResult createBuffer(  VkBufferCreateInfo const* pCreateInfo, VkBuffer * pBuffer){
		rs_check(this->vkCreateBuffer!=nullptr);
		return this->vkCreateBuffer(handle, pCreateInfo, nullptr, pBuffer);
	}

	void destroyBuffer(  VkBuffer  buffer){
		rs_check(this->vkDestroyBuffer!=nullptr);
		this->vkDestroyBuffer(handle, buffer, nullptr);
	}

	VkResult createBufferView(  VkBufferViewCreateInfo const* pCreateInfo, VkBufferView * pView){
		rs_check(this->vkCreateBufferView!=nullptr);
		return this->vkCreateBufferView(handle, pCreateInfo, nullptr, pView);
	}

	void destroyBufferView(  VkBufferView  bufferView){
		rs_check(this->vkDestroyBufferView!=nullptr);
		this->vkDestroyBufferView(handle, bufferView, nullptr);
	}

	VkResult createImage(  VkImageCreateInfo const* pCreateInfo, VkImage * pImage){
		rs_check(this->vkCreateImage!=nullptr);
		return this->vkCreateImage(handle, pCreateInfo, nullptr, pImage);
	}

	void destroyImage(  VkImage  image){
		rs_check(this->vkDestroyImage!=nullptr);
		this->vkDestroyImage(handle, image, nullptr);
	}

	void getImageSubresourceLayout(  VkImage  image, VkImageSubresource const* pSubresource, VkSubresourceLayout * pLayout){
		rs_check(this->vkGetImageSubresourceLayout!=nullptr);
		this->vkGetImageSubresourceLayout(handle, image, pSubresource, pLayout);
	}

	VkResult createImageView(  VkImageViewCreateInfo const* pCreateInfo, VkImageView * pView){
		rs_check(this->vkCreateImageView!=nullptr);
		return this->vkCreateImageView(handle, pCreateInfo, nullptr, pView);
	}

	void destroyImageView(  VkImageView  imageView){
		rs_check(this->vkDestroyImageView!=nullptr);
		this->vkDestroyImageView(handle, imageView, nullptr);
	}

	VkResult createShaderModule(  VkShaderModuleCreateInfo const* pCreateInfo, VkShaderModule * pShaderModule){
		rs_check(this->vkCreateShaderModule!=nullptr);
		return this->vkCreateShaderModule(handle, pCreateInfo, nullptr, pShaderModule);
	}

	void destroyShaderModule(  VkShaderModule  shaderModule){
		rs_check(this->vkDestroyShaderModule!=nullptr);
		this->vkDestroyShaderModule(handle, shaderModule, nullptr);
	}

	VkResult createPipelineCache(  VkPipelineCacheCreateInfo const* pCreateInfo, VkPipelineCache * pPipelineCache){
		rs_check(this->vkCreatePipelineCache!=nullptr);
		return this->vkCreatePipelineCache(handle, pCreateInfo, nullptr, pPipelineCache);
	}

	void destroyPipelineCache(  VkPipelineCache  pipelineCache){
		rs_check(this->vkDestroyPipelineCache!=nullptr);
		this->vkDestroyPipelineCache(handle, pipelineCache, nullptr);
	}

	VkResult getPipelineCacheData(  VkPipelineCache  pipelineCache, size_t * pDataSize, void * pData){
		rs_check(this->vkGetPipelineCacheData!=nullptr);
		return this->vkGetPipelineCacheData(handle, pipelineCache, pDataSize, pData);
	}

	VkResult mergePipelineCaches(  VkPipelineCache  dstCache, uint32_t  srcCacheCount, VkPipelineCache const* pSrcCaches){
		rs_check(this->vkMergePipelineCaches!=nullptr);
		return this->vkMergePipelineCaches(handle, dstCache, srcCacheCount, pSrcCaches);
	}

	VkResult createGraphicsPipelines(  VkPipelineCache  pipelineCache, uint32_t  createInfoCount, VkGraphicsPipelineCreateInfo const* pCreateInfos, VkPipeline * pPipelines){
		rs_check(this->vkCreateGraphicsPipelines!=nullptr);
		return this->vkCreateGraphicsPipelines(handle, pipelineCache, createInfoCount, pCreateInfos, nullptr, pPipelines);
	}

	VkResult createComputePipelines(  VkPipelineCache  pipelineCache, uint32_t  createInfoCount, VkComputePipelineCreateInfo const* pCreateInfos, VkPipeline * pPipelines){
		rs_check(this->vkCreateComputePipelines!=nullptr);
		return this->vkCreateComputePipelines(handle, pipelineCache, createInfoCount, pCreateInfos, nullptr, pPipelines);
	}

	void destroyPipeline(  VkPipeline  pipeline){
		rs_check(this->vkDestroyPipeline!=nullptr);
		this->vkDestroyPipeline(handle, pipeline, nullptr);
	}

	VkResult createPipelineLayout(  VkPipelineLayoutCreateInfo const* pCreateInfo, VkPipelineLayout * pPipelineLayout){
		rs_check(this->vkCreatePipelineLayout!=nullptr);
		return this->vkCreatePipelineLayout(handle, pCreateInfo, nullptr, pPipelineLayout);
	}

	void destroyPipelineLayout(  VkPipelineLayout  pipelineLayout){
		rs_check(this->vkDestroyPipelineLayout!=nullptr);
		this->vkDestroyPipelineLayout(handle, pipelineLayout, nullptr);
	}

	VkResult createSampler(  VkSamplerCreateInfo const* pCreateInfo, VkSampler * pSampler){
		rs_check(this->vkCreateSampler!=nullptr);
		return this->vkCreateSampler(handle, pCreateInfo, nullptr, pSampler);
	}

	void destroySampler(  VkSampler  sampler){
		rs_check(this->vkDestroySampler!=nullptr);
		this->vkDestroySampler(handle, sampler, nullptr);
	}

	VkResult createDescriptorSetLayout(  VkDescriptorSetLayoutCreateInfo const* pCreateInfo, VkDescriptorSetLayout * pSetLayout){
		rs_check(this->vkCreateDescriptorSetLayout!=nullptr);
		return this->vkCreateDescriptorSetLayout(handle, pCreateInfo, nullptr, pSetLayout);
	}

	void destroyDescriptorSetLayout(  VkDescriptorSetLayout  descriptorSetLayout){
		rs_check(this->vkDestroyDescriptorSetLayout!=nullptr);
		this->vkDestroyDescriptorSetLayout(handle, descriptorSetLayout, nullptr);
	}

	VkResult createDescriptorPool(  VkDescriptorPoolCreateInfo const* pCreateInfo, VkDescriptorPool * pDescriptorPool){
		rs_check(this->vkCreateDescriptorPool!=nullptr);
		return this->vkCreateDescriptorPool(handle, pCreateInfo, nullptr, pDescriptorPool);
	}

	void destroyDescriptorPool(  VkDescriptorPool  descriptorPool){
		rs_check(this->vkDestroyDescriptorPool!=nullptr);
		this->vkDestroyDescriptorPool(handle, descriptorPool, nullptr);
	}

	VkResult resetDescriptorPool(  VkDescriptorPool  descriptorPool, VkDescriptorPoolResetFlags  flags){
		rs_check(this->vkResetDescriptorPool!=nullptr);
		return this->vkResetDescriptorPool(handle, descriptorPool, flags);
	}

	VkResult allocateDescriptorSets(  VkDescriptorSetAllocateInfo const* pAllocateInfo, VkDescriptorSet * pDescriptorSets){
		rs_check(this->vkAllocateDescriptorSets!=nullptr);
		return this->vkAllocateDescriptorSets(handle, pAllocateInfo, pDescriptorSets);
	}

	VkResult freeDescriptorSets(  VkDescriptorPool  descriptorPool, uint32_t  descriptorSetCount, VkDescriptorSet const* pDescriptorSets){
		rs_check(this->vkFreeDescriptorSets!=nullptr);
		return this->vkFreeDescriptorSets(handle, descriptorPool, descriptorSetCount, pDescriptorSets);
	}

	void updateDescriptorSets(  uint32_t  descriptorWriteCount, VkWriteDescriptorSet const* pDescriptorWrites, uint32_t  descriptorCopyCount, VkCopyDescriptorSet const* pDescriptorCopies){
		rs_check(this->vkUpdateDescriptorSets!=nullptr);
		this->vkUpdateDescriptorSets(handle, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
	}

	VkResult createFramebuffer(  VkFramebufferCreateInfo const* pCreateInfo, VkFramebuffer * pFramebuffer){
		rs_check(this->vkCreateFramebuffer!=nullptr);
		return this->vkCreateFramebuffer(handle, pCreateInfo, nullptr, pFramebuffer);
	}

	void destroyFramebuffer(  VkFramebuffer  framebuffer){
		rs_check(this->vkDestroyFramebuffer!=nullptr);
		this->vkDestroyFramebuffer(handle, framebuffer, nullptr);
	}

	VkResult createRenderPass(  VkRenderPassCreateInfo const* pCreateInfo, VkRenderPass * pRenderPass){
		rs_check(this->vkCreateRenderPass!=nullptr);
		return this->vkCreateRenderPass(handle, pCreateInfo, nullptr, pRenderPass);
	}

	void destroyRenderPass(  VkRenderPass  renderPass){
		rs_check(this->vkDestroyRenderPass!=nullptr);
		this->vkDestroyRenderPass(handle, renderPass, nullptr);
	}

	void getRenderAreaGranularity(  VkRenderPass  renderPass, VkExtent2D * pGranularity){
		rs_check(this->vkGetRenderAreaGranularity!=nullptr);
		this->vkGetRenderAreaGranularity(handle, renderPass, pGranularity);
	}

	VkResult createCommandPool(  VkCommandPoolCreateInfo const* pCreateInfo, VkCommandPool * pCommandPool){
		rs_check(this->vkCreateCommandPool!=nullptr);
		return this->vkCreateCommandPool(handle, pCreateInfo, nullptr, pCommandPool);
	}

	void destroyCommandPool(  VkCommandPool  commandPool){
		rs_check(this->vkDestroyCommandPool!=nullptr);
		this->vkDestroyCommandPool(handle, commandPool, nullptr);
	}

	VkResult resetCommandPool(  VkCommandPool  commandPool, VkCommandPoolResetFlags  flags){
		rs_check(this->vkResetCommandPool!=nullptr);
		return this->vkResetCommandPool(handle, commandPool, flags);
	}

	VkResult allocateCommandBuffers(  VkCommandBufferAllocateInfo const* pAllocateInfo, VkCommandBuffer * pCommandBuffers){
		rs_check(this->vkAllocateCommandBuffers!=nullptr);
		return this->vkAllocateCommandBuffers(handle, pAllocateInfo, pCommandBuffers);
	}

	void freeCommandBuffers(  VkCommandPool  commandPool, uint32_t  commandBufferCount, VkCommandBuffer const* pCommandBuffers){
		rs_check(this->vkFreeCommandBuffers!=nullptr);
		this->vkFreeCommandBuffers(handle, commandPool, commandBufferCount, pCommandBuffers);
	}

	VkResult createSwapchainKHR(  VkSwapchainCreateInfoKHR const* pCreateInfo, VkSwapchainKHR * pSwapchain){
		rs_check(this->vkCreateSwapchainKHR!=nullptr);
		return this->vkCreateSwapchainKHR(handle, pCreateInfo, nullptr, pSwapchain);
	}

	void destroySwapchainKHR(  VkSwapchainKHR  swapchain){
		rs_check(this->vkDestroySwapchainKHR!=nullptr);
		this->vkDestroySwapchainKHR(handle, swapchain, nullptr);
	}

	VkResult getSwapchainImagesKHR(  VkSwapchainKHR  swapchain, uint32_t * pSwapchainImageCount, VkImage * pSwapchainImages){
		rs_check(this->vkGetSwapchainImagesKHR!=nullptr);
		return this->vkGetSwapchainImagesKHR(handle, swapchain, pSwapchainImageCount, pSwapchainImages);
	}

	VkResult acquireNextImageKHR(  VkSwapchainKHR  swapchain, uint64_t  timeout, VkSemaphore  semaphore, VkFence  fence, uint32_t * pImageIndex){
		rs_check(this->vkAcquireNextImageKHR!=nullptr);
		return this->vkAcquireNextImageKHR(handle, swapchain, timeout, semaphore, fence, pImageIndex);
	}

	VkResult debugMarkerSetObjectNameEXT(  VkDebugMarkerObjectNameInfoEXT const* pNameInfo){
		rs_check(this->vkDebugMarkerSetObjectNameEXT!=nullptr);
		return this->vkDebugMarkerSetObjectNameEXT(handle, pNameInfo);
	}

	VkResult debugMarkerSetObjectTagEXT(  VkDebugMarkerObjectTagInfoEXT const* pTagInfo){
		rs_check(this->vkDebugMarkerSetObjectTagEXT!=nullptr);
		return this->vkDebugMarkerSetObjectTagEXT(handle, pTagInfo);
	}

	void trimCommandPool(  VkCommandPool  commandPool, VkCommandPoolTrimFlags  flags){
		rs_check(this->vkTrimCommandPool!=nullptr);
		this->vkTrimCommandPool(handle, commandPool, flags);
	}

	void trimCommandPoolKHR(  VkCommandPool  commandPool, VkCommandPoolTrimFlags  flags){
		rs_check(this->vkTrimCommandPoolKHR!=nullptr);
		this->vkTrimCommandPoolKHR(handle, commandPool, flags);
	}

	VkResult getMemoryFdKHR(  VkMemoryGetFdInfoKHR const* pGetFdInfo, int * pFd){
		rs_check(this->vkGetMemoryFdKHR!=nullptr);
		return this->vkGetMemoryFdKHR(handle, pGetFdInfo, pFd);
	}

	VkResult getMemoryFdPropertiesKHR(  VkExternalMemoryHandleTypeFlagBits  handleType, int  fd, VkMemoryFdPropertiesKHR * pMemoryFdProperties){
		rs_check(this->vkGetMemoryFdPropertiesKHR!=nullptr);
		return this->vkGetMemoryFdPropertiesKHR(handle, handleType, fd, pMemoryFdProperties);
	}

	VkResult getSemaphoreFdKHR(  VkSemaphoreGetFdInfoKHR const* pGetFdInfo, int * pFd){
		rs_check(this->vkGetSemaphoreFdKHR!=nullptr);
		return this->vkGetSemaphoreFdKHR(handle, pGetFdInfo, pFd);
	}

	VkResult importSemaphoreFdKHR(  VkImportSemaphoreFdInfoKHR const* pImportSemaphoreFdInfo){
		rs_check(this->vkImportSemaphoreFdKHR!=nullptr);
		return this->vkImportSemaphoreFdKHR(handle, pImportSemaphoreFdInfo);
	}

	VkResult getFenceFdKHR(  VkFenceGetFdInfoKHR const* pGetFdInfo, int * pFd){
		rs_check(this->vkGetFenceFdKHR!=nullptr);
		return this->vkGetFenceFdKHR(handle, pGetFdInfo, pFd);
	}

	VkResult importFenceFdKHR(  VkImportFenceFdInfoKHR const* pImportFenceFdInfo){
		rs_check(this->vkImportFenceFdKHR!=nullptr);
		return this->vkImportFenceFdKHR(handle, pImportFenceFdInfo);
	}

	void getDeviceGroupPeerMemoryFeatures(  uint32_t  heapIndex, uint32_t  localDeviceIndex, uint32_t  remoteDeviceIndex, VkPeerMemoryFeatureFlags * pPeerMemoryFeatures){
		rs_check(this->vkGetDeviceGroupPeerMemoryFeatures!=nullptr);
		this->vkGetDeviceGroupPeerMemoryFeatures(handle, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
	}

	void getDeviceGroupPeerMemoryFeaturesKHR(  uint32_t  heapIndex, uint32_t  localDeviceIndex, uint32_t  remoteDeviceIndex, VkPeerMemoryFeatureFlags * pPeerMemoryFeatures){
		rs_check(this->vkGetDeviceGroupPeerMemoryFeaturesKHR!=nullptr);
		this->vkGetDeviceGroupPeerMemoryFeaturesKHR(handle, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
	}

	VkResult bindBufferMemory2(  uint32_t  bindInfoCount, VkBindBufferMemoryInfo const* pBindInfos){
		rs_check(this->vkBindBufferMemory2!=nullptr);
		return this->vkBindBufferMemory2(handle, bindInfoCount, pBindInfos);
	}

	VkResult bindBufferMemory2KHR(  uint32_t  bindInfoCount, VkBindBufferMemoryInfo const* pBindInfos){
		rs_check(this->vkBindBufferMemory2KHR!=nullptr);
		return this->vkBindBufferMemory2KHR(handle, bindInfoCount, pBindInfos);
	}

	VkResult bindImageMemory2(  uint32_t  bindInfoCount, VkBindImageMemoryInfo const* pBindInfos){
		rs_check(this->vkBindImageMemory2!=nullptr);
		return this->vkBindImageMemory2(handle, bindInfoCount, pBindInfos);
	}

	VkResult bindImageMemory2KHR(  uint32_t  bindInfoCount, VkBindImageMemoryInfo const* pBindInfos){
		rs_check(this->vkBindImageMemory2KHR!=nullptr);
		return this->vkBindImageMemory2KHR(handle, bindInfoCount, pBindInfos);
	}

	VkResult getDeviceGroupPresentCapabilitiesKHR(  VkDeviceGroupPresentCapabilitiesKHR * pDeviceGroupPresentCapabilities){
		rs_check(this->vkGetDeviceGroupPresentCapabilitiesKHR!=nullptr);
		return this->vkGetDeviceGroupPresentCapabilitiesKHR(handle, pDeviceGroupPresentCapabilities);
	}

	VkResult getDeviceGroupSurfacePresentModesKHR(  VkSurfaceKHR  surface, VkDeviceGroupPresentModeFlagsKHR * pModes){
		rs_check(this->vkGetDeviceGroupSurfacePresentModesKHR!=nullptr);
		return this->vkGetDeviceGroupSurfacePresentModesKHR(handle, surface, pModes);
	}

	VkResult acquireNextImage2KHR(  VkAcquireNextImageInfoKHR const* pAcquireInfo, uint32_t * pImageIndex){
		rs_check(this->vkAcquireNextImage2KHR!=nullptr);
		return this->vkAcquireNextImage2KHR(handle, pAcquireInfo, pImageIndex);
	}

	VkResult createDescriptorUpdateTemplate(  VkDescriptorUpdateTemplateCreateInfo const* pCreateInfo, VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate){
		rs_check(this->vkCreateDescriptorUpdateTemplate!=nullptr);
		return this->vkCreateDescriptorUpdateTemplate(handle, pCreateInfo, nullptr, pDescriptorUpdateTemplate);
	}

	VkResult createDescriptorUpdateTemplateKHR(  VkDescriptorUpdateTemplateCreateInfo const* pCreateInfo, VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate){
		rs_check(this->vkCreateDescriptorUpdateTemplateKHR!=nullptr);
		return this->vkCreateDescriptorUpdateTemplateKHR(handle, pCreateInfo, nullptr, pDescriptorUpdateTemplate);
	}

	void destroyDescriptorUpdateTemplate(  VkDescriptorUpdateTemplate  descriptorUpdateTemplate){
		rs_check(this->vkDestroyDescriptorUpdateTemplate!=nullptr);
		this->vkDestroyDescriptorUpdateTemplate(handle, descriptorUpdateTemplate, nullptr);
	}

	void destroyDescriptorUpdateTemplateKHR(  VkDescriptorUpdateTemplate  descriptorUpdateTemplate){
		rs_check(this->vkDestroyDescriptorUpdateTemplateKHR!=nullptr);
		this->vkDestroyDescriptorUpdateTemplateKHR(handle, descriptorUpdateTemplate, nullptr);
	}

	void updateDescriptorSetWithTemplate(  VkDescriptorSet  descriptorSet, VkDescriptorUpdateTemplate  descriptorUpdateTemplate, void const* pData){
		rs_check(this->vkUpdateDescriptorSetWithTemplate!=nullptr);
		this->vkUpdateDescriptorSetWithTemplate(handle, descriptorSet, descriptorUpdateTemplate, pData);
	}

	void updateDescriptorSetWithTemplateKHR(  VkDescriptorSet  descriptorSet, VkDescriptorUpdateTemplate  descriptorUpdateTemplate, void const* pData){
		rs_check(this->vkUpdateDescriptorSetWithTemplateKHR!=nullptr);
		this->vkUpdateDescriptorSetWithTemplateKHR(handle, descriptorSet, descriptorUpdateTemplate, pData);
	}

	void setHdrMetadataEXT(  uint32_t  swapchainCount, VkSwapchainKHR const* pSwapchains, VkHdrMetadataEXT const* pMetadata){
		rs_check(this->vkSetHdrMetadataEXT!=nullptr);
		this->vkSetHdrMetadataEXT(handle, swapchainCount, pSwapchains, pMetadata);
	}

	VkResult getSwapchainStatusKHR(  VkSwapchainKHR  swapchain){
		rs_check(this->vkGetSwapchainStatusKHR!=nullptr);
		return this->vkGetSwapchainStatusKHR(handle, swapchain);
	}

	VkResult getRefreshCycleDurationGOOGLE(  VkSwapchainKHR  swapchain, VkRefreshCycleDurationGOOGLE * pDisplayTimingProperties){
		rs_check(this->vkGetRefreshCycleDurationGOOGLE!=nullptr);
		return this->vkGetRefreshCycleDurationGOOGLE(handle, swapchain, pDisplayTimingProperties);
	}

	VkResult getPastPresentationTimingGOOGLE(  VkSwapchainKHR  swapchain, uint32_t * pPresentationTimingCount, VkPastPresentationTimingGOOGLE * pPresentationTimings){
		rs_check(this->vkGetPastPresentationTimingGOOGLE!=nullptr);
		return this->vkGetPastPresentationTimingGOOGLE(handle, swapchain, pPresentationTimingCount, pPresentationTimings);
	}

	void getBufferMemoryRequirements2(  VkBufferMemoryRequirementsInfo2 const* pInfo, VkMemoryRequirements2 * pMemoryRequirements){
		rs_check(this->vkGetBufferMemoryRequirements2!=nullptr);
		this->vkGetBufferMemoryRequirements2(handle, pInfo, pMemoryRequirements);
	}

	void getBufferMemoryRequirements2KHR(  VkBufferMemoryRequirementsInfo2 const* pInfo, VkMemoryRequirements2 * pMemoryRequirements){
		rs_check(this->vkGetBufferMemoryRequirements2KHR!=nullptr);
		this->vkGetBufferMemoryRequirements2KHR(handle, pInfo, pMemoryRequirements);
	}

	void getImageMemoryRequirements2(  VkImageMemoryRequirementsInfo2 const* pInfo, VkMemoryRequirements2 * pMemoryRequirements){
		rs_check(this->vkGetImageMemoryRequirements2!=nullptr);
		this->vkGetImageMemoryRequirements2(handle, pInfo, pMemoryRequirements);
	}

	void getImageMemoryRequirements2KHR(  VkImageMemoryRequirementsInfo2 const* pInfo, VkMemoryRequirements2 * pMemoryRequirements){
		rs_check(this->vkGetImageMemoryRequirements2KHR!=nullptr);
		this->vkGetImageMemoryRequirements2KHR(handle, pInfo, pMemoryRequirements);
	}

	void getImageSparseMemoryRequirements2(  VkImageSparseMemoryRequirementsInfo2 const* pInfo, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements){
		rs_check(this->vkGetImageSparseMemoryRequirements2!=nullptr);
		this->vkGetImageSparseMemoryRequirements2(handle, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
	}

	void getImageSparseMemoryRequirements2KHR(  VkImageSparseMemoryRequirementsInfo2 const* pInfo, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements){
		rs_check(this->vkGetImageSparseMemoryRequirements2KHR!=nullptr);
		this->vkGetImageSparseMemoryRequirements2KHR(handle, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
	}

	VkResult createSamplerYcbcrConversion(  VkSamplerYcbcrConversionCreateInfo const* pCreateInfo, VkSamplerYcbcrConversion * pYcbcrConversion){
		rs_check(this->vkCreateSamplerYcbcrConversion!=nullptr);
		return this->vkCreateSamplerYcbcrConversion(handle, pCreateInfo, nullptr, pYcbcrConversion);
	}

	VkResult createSamplerYcbcrConversionKHR(  VkSamplerYcbcrConversionCreateInfo const* pCreateInfo, VkSamplerYcbcrConversion * pYcbcrConversion){
		rs_check(this->vkCreateSamplerYcbcrConversionKHR!=nullptr);
		return this->vkCreateSamplerYcbcrConversionKHR(handle, pCreateInfo, nullptr, pYcbcrConversion);
	}

	void destroySamplerYcbcrConversion(  VkSamplerYcbcrConversion  ycbcrConversion){
		rs_check(this->vkDestroySamplerYcbcrConversion!=nullptr);
		this->vkDestroySamplerYcbcrConversion(handle, ycbcrConversion, nullptr);
	}

	void destroySamplerYcbcrConversionKHR(  VkSamplerYcbcrConversion  ycbcrConversion){
		rs_check(this->vkDestroySamplerYcbcrConversionKHR!=nullptr);
		this->vkDestroySamplerYcbcrConversionKHR(handle, ycbcrConversion, nullptr);
	}

	void getDeviceQueue2(  VkDeviceQueueInfo2 const* pQueueInfo, VkQueue * pQueue){
		rs_check(this->vkGetDeviceQueue2!=nullptr);
		this->vkGetDeviceQueue2(handle, pQueueInfo, pQueue);
	}

	VkResult createValidationCacheEXT(  VkValidationCacheCreateInfoEXT const* pCreateInfo, VkValidationCacheEXT * pValidationCache){
		rs_check(this->vkCreateValidationCacheEXT!=nullptr);
		return this->vkCreateValidationCacheEXT(handle, pCreateInfo, nullptr, pValidationCache);
	}

	void destroyValidationCacheEXT(  VkValidationCacheEXT  validationCache){
		rs_check(this->vkDestroyValidationCacheEXT!=nullptr);
		this->vkDestroyValidationCacheEXT(handle, validationCache, nullptr);
	}

	VkResult getValidationCacheDataEXT(  VkValidationCacheEXT  validationCache, size_t * pDataSize, void * pData){
		rs_check(this->vkGetValidationCacheDataEXT!=nullptr);
		return this->vkGetValidationCacheDataEXT(handle, validationCache, pDataSize, pData);
	}

	VkResult mergeValidationCachesEXT(  VkValidationCacheEXT  dstCache, uint32_t  srcCacheCount, VkValidationCacheEXT const* pSrcCaches){
		rs_check(this->vkMergeValidationCachesEXT!=nullptr);
		return this->vkMergeValidationCachesEXT(handle, dstCache, srcCacheCount, pSrcCaches);
	}

	void getDescriptorSetLayoutSupport(  VkDescriptorSetLayoutCreateInfo const* pCreateInfo, VkDescriptorSetLayoutSupport * pSupport){
		rs_check(this->vkGetDescriptorSetLayoutSupport!=nullptr);
		this->vkGetDescriptorSetLayoutSupport(handle, pCreateInfo, pSupport);
	}

	void getDescriptorSetLayoutSupportKHR(  VkDescriptorSetLayoutCreateInfo const* pCreateInfo, VkDescriptorSetLayoutSupport * pSupport){
		rs_check(this->vkGetDescriptorSetLayoutSupportKHR!=nullptr);
		this->vkGetDescriptorSetLayoutSupportKHR(handle, pCreateInfo, pSupport);
	}

	VkResult createRenderPass2(  VkRenderPassCreateInfo2 const* pCreateInfo, VkRenderPass * pRenderPass){
		rs_check(this->vkCreateRenderPass2!=nullptr);
		return this->vkCreateRenderPass2(handle, pCreateInfo, nullptr, pRenderPass);
	}

	VkResult createRenderPass2KHR(  VkRenderPassCreateInfo2 const* pCreateInfo, VkRenderPass * pRenderPass){
		rs_check(this->vkCreateRenderPass2KHR!=nullptr);
		return this->vkCreateRenderPass2KHR(handle, pCreateInfo, nullptr, pRenderPass);
	}

	VkResult getSemaphoreCounterValue(  VkSemaphore  semaphore, uint64_t * pValue){
		rs_check(this->vkGetSemaphoreCounterValue!=nullptr);
		return this->vkGetSemaphoreCounterValue(handle, semaphore, pValue);
	}

	VkResult waitSemaphores(  VkSemaphoreWaitInfo const* pWaitInfo, uint64_t  timeout){
		rs_check(this->vkWaitSemaphores!=nullptr);
		return this->vkWaitSemaphores(handle, pWaitInfo, timeout);
	}

	VkResult signalSemaphore(  VkSemaphoreSignalInfo const* pSignalInfo){
		rs_check(this->vkSignalSemaphore!=nullptr);
		return this->vkSignalSemaphore(handle, pSignalInfo);
	}

	uint64_t getBufferOpaqueCaptureAddress(  VkBufferDeviceAddressInfo const* pInfo){
		rs_check(this->vkGetBufferOpaqueCaptureAddress!=nullptr);
		return this->vkGetBufferOpaqueCaptureAddress(handle, pInfo);
	}

	VkDeviceAddress getBufferDeviceAddress(  VkBufferDeviceAddressInfo const* pInfo){
		rs_check(this->vkGetBufferDeviceAddress!=nullptr);
		return this->vkGetBufferDeviceAddress(handle, pInfo);
	}

	uint64_t getDeviceMemoryOpaqueCaptureAddress(  VkDeviceMemoryOpaqueCaptureAddressInfo const* pInfo){
		rs_check(this->vkGetDeviceMemoryOpaqueCaptureAddress!=nullptr);
		return this->vkGetDeviceMemoryOpaqueCaptureAddress(handle, pInfo);
	}
};

struct WCommandBuffer{
	VkCommandBuffer handle;
	VkInstDispatchTable& DispatchTable;
	WCommandBuffer(VkCommandBuffer inHandle, VkInstDispatchTable& inDispatchTable)
	: handle{ inHandle }
	, DispatchTable{ inDispatchTable }
	{}

	VkResult beginCommandBuffer(  VkCommandBufferBeginInfo const* pBeginInfo){
		rs_check(DispatchTable.vkBeginCommandBuffer!=nullptr);
		return DispatchTable.vkBeginCommandBuffer(handle, pBeginInfo);
	}

	VkResult endCommandBuffer( ){
		rs_check(DispatchTable.vkEndCommandBuffer!=nullptr);
		return DispatchTable.vkEndCommandBuffer(handle);
	}

	VkResult resetCommandBuffer(  VkCommandBufferResetFlags  flags){
		rs_check(DispatchTable.vkResetCommandBuffer!=nullptr);
		return DispatchTable.vkResetCommandBuffer(handle, flags);
	}

	void cmdBindPipeline(  VkPipelineBindPoint  pipelineBindPoint, VkPipeline  pipeline){
		rs_check(DispatchTable.vkCmdBindPipeline!=nullptr);
		DispatchTable.vkCmdBindPipeline(handle, pipelineBindPoint, pipeline);
	}

	void cmdSetViewport(  uint32_t  firstViewport, uint32_t  viewportCount, VkViewport const* pViewports){
		rs_check(DispatchTable.vkCmdSetViewport!=nullptr);
		DispatchTable.vkCmdSetViewport(handle, firstViewport, viewportCount, pViewports);
	}

	void cmdSetScissor(  uint32_t  firstScissor, uint32_t  scissorCount, VkRect2D const* pScissors){
		rs_check(DispatchTable.vkCmdSetScissor!=nullptr);
		DispatchTable.vkCmdSetScissor(handle, firstScissor, scissorCount, pScissors);
	}

	void cmdSetLineWidth(  float  lineWidth){
		rs_check(DispatchTable.vkCmdSetLineWidth!=nullptr);
		DispatchTable.vkCmdSetLineWidth(handle, lineWidth);
	}

	void cmdSetDepthBias(  float  depthBiasConstantFactor, float  depthBiasClamp, float  depthBiasSlopeFactor){
		rs_check(DispatchTable.vkCmdSetDepthBias!=nullptr);
		DispatchTable.vkCmdSetDepthBias(handle, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
	}

	void cmdSetBlendConstants(  float const blendConstants[4]){
		rs_check(DispatchTable.vkCmdSetBlendConstants!=nullptr);
		DispatchTable.vkCmdSetBlendConstants(handle, blendConstants);
	}

	void cmdSetDepthBounds(  float  minDepthBounds, float  maxDepthBounds){
		rs_check(DispatchTable.vkCmdSetDepthBounds!=nullptr);
		DispatchTable.vkCmdSetDepthBounds(handle, minDepthBounds, maxDepthBounds);
	}

	void cmdSetStencilCompareMask(  VkStencilFaceFlags  faceMask, uint32_t  compareMask){
		rs_check(DispatchTable.vkCmdSetStencilCompareMask!=nullptr);
		DispatchTable.vkCmdSetStencilCompareMask(handle, faceMask, compareMask);
	}

	void cmdSetStencilWriteMask(  VkStencilFaceFlags  faceMask, uint32_t  writeMask){
		rs_check(DispatchTable.vkCmdSetStencilWriteMask!=nullptr);
		DispatchTable.vkCmdSetStencilWriteMask(handle, faceMask, writeMask);
	}

	void cmdSetStencilReference(  VkStencilFaceFlags  faceMask, uint32_t  reference){
		rs_check(DispatchTable.vkCmdSetStencilReference!=nullptr);
		DispatchTable.vkCmdSetStencilReference(handle, faceMask, reference);
	}

	void cmdBindDescriptorSets(  VkPipelineBindPoint  pipelineBindPoint, VkPipelineLayout  layout, uint32_t  firstSet, uint32_t  descriptorSetCount, VkDescriptorSet const* pDescriptorSets, uint32_t  dynamicOffsetCount, uint32_t const* pDynamicOffsets){
		rs_check(DispatchTable.vkCmdBindDescriptorSets!=nullptr);
		DispatchTable.vkCmdBindDescriptorSets(handle, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
	}

	void cmdBindIndexBuffer(  VkBuffer  buffer, VkDeviceSize  offset, VkIndexType  indexType){
		rs_check(DispatchTable.vkCmdBindIndexBuffer!=nullptr);
		DispatchTable.vkCmdBindIndexBuffer(handle, buffer, offset, indexType);
	}

	void cmdBindVertexBuffers(  uint32_t  firstBinding, uint32_t  bindingCount, VkBuffer const* pBuffers, VkDeviceSize const* pOffsets){
		rs_check(DispatchTable.vkCmdBindVertexBuffers!=nullptr);
		DispatchTable.vkCmdBindVertexBuffers(handle, firstBinding, bindingCount, pBuffers, pOffsets);
	}

	void cmdDraw(  uint32_t  vertexCount, uint32_t  instanceCount, uint32_t  firstVertex, uint32_t  firstInstance){
		rs_check(DispatchTable.vkCmdDraw!=nullptr);
		DispatchTable.vkCmdDraw(handle, vertexCount, instanceCount, firstVertex, firstInstance);
	}

	void cmdDrawIndexed(  uint32_t  indexCount, uint32_t  instanceCount, uint32_t  firstIndex, int32_t  vertexOffset, uint32_t  firstInstance){
		rs_check(DispatchTable.vkCmdDrawIndexed!=nullptr);
		DispatchTable.vkCmdDrawIndexed(handle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
	}

	void cmdDrawIndirect(  VkBuffer  buffer, VkDeviceSize  offset, uint32_t  drawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndirect!=nullptr);
		DispatchTable.vkCmdDrawIndirect(handle, buffer, offset, drawCount, stride);
	}

	void cmdDrawIndexedIndirect(  VkBuffer  buffer, VkDeviceSize  offset, uint32_t  drawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndexedIndirect!=nullptr);
		DispatchTable.vkCmdDrawIndexedIndirect(handle, buffer, offset, drawCount, stride);
	}

	void cmdDispatch(  uint32_t  groupCountX, uint32_t  groupCountY, uint32_t  groupCountZ){
		rs_check(DispatchTable.vkCmdDispatch!=nullptr);
		DispatchTable.vkCmdDispatch(handle, groupCountX, groupCountY, groupCountZ);
	}

	void cmdDispatchIndirect(  VkBuffer  buffer, VkDeviceSize  offset){
		rs_check(DispatchTable.vkCmdDispatchIndirect!=nullptr);
		DispatchTable.vkCmdDispatchIndirect(handle, buffer, offset);
	}

	void cmdCopyBuffer(  VkBuffer  srcBuffer, VkBuffer  dstBuffer, uint32_t  regionCount, VkBufferCopy const* pRegions){
		rs_check(DispatchTable.vkCmdCopyBuffer!=nullptr);
		DispatchTable.vkCmdCopyBuffer(handle, srcBuffer, dstBuffer, regionCount, pRegions);
	}

	void cmdCopyImage(  VkImage  srcImage, VkImageLayout  srcImageLayout, VkImage  dstImage, VkImageLayout  dstImageLayout, uint32_t  regionCount, VkImageCopy const* pRegions){
		rs_check(DispatchTable.vkCmdCopyImage!=nullptr);
		DispatchTable.vkCmdCopyImage(handle, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
	}

	void cmdBlitImage(  VkImage  srcImage, VkImageLayout  srcImageLayout, VkImage  dstImage, VkImageLayout  dstImageLayout, uint32_t  regionCount, VkImageBlit const* pRegions, VkFilter  filter){
		rs_check(DispatchTable.vkCmdBlitImage!=nullptr);
		DispatchTable.vkCmdBlitImage(handle, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
	}

	void cmdCopyBufferToImage(  VkBuffer  srcBuffer, VkImage  dstImage, VkImageLayout  dstImageLayout, uint32_t  regionCount, VkBufferImageCopy const* pRegions){
		rs_check(DispatchTable.vkCmdCopyBufferToImage!=nullptr);
		DispatchTable.vkCmdCopyBufferToImage(handle, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
	}

	void cmdCopyImageToBuffer(  VkImage  srcImage, VkImageLayout  srcImageLayout, VkBuffer  dstBuffer, uint32_t  regionCount, VkBufferImageCopy const* pRegions){
		rs_check(DispatchTable.vkCmdCopyImageToBuffer!=nullptr);
		DispatchTable.vkCmdCopyImageToBuffer(handle, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
	}

	void cmdUpdateBuffer(  VkBuffer  dstBuffer, VkDeviceSize  dstOffset, VkDeviceSize  dataSize, void const* pData){
		rs_check(DispatchTable.vkCmdUpdateBuffer!=nullptr);
		DispatchTable.vkCmdUpdateBuffer(handle, dstBuffer, dstOffset, dataSize, pData);
	}

	void cmdFillBuffer(  VkBuffer  dstBuffer, VkDeviceSize  dstOffset, VkDeviceSize  size, uint32_t  data){
		rs_check(DispatchTable.vkCmdFillBuffer!=nullptr);
		DispatchTable.vkCmdFillBuffer(handle, dstBuffer, dstOffset, size, data);
	}

	void cmdClearColorImage(  VkImage  image, VkImageLayout  imageLayout, VkClearColorValue const* pColor, uint32_t  rangeCount, VkImageSubresourceRange const* pRanges){
		rs_check(DispatchTable.vkCmdClearColorImage!=nullptr);
		DispatchTable.vkCmdClearColorImage(handle, image, imageLayout, pColor, rangeCount, pRanges);
	}

	void cmdClearDepthStencilImage(  VkImage  image, VkImageLayout  imageLayout, VkClearDepthStencilValue const* pDepthStencil, uint32_t  rangeCount, VkImageSubresourceRange const* pRanges){
		rs_check(DispatchTable.vkCmdClearDepthStencilImage!=nullptr);
		DispatchTable.vkCmdClearDepthStencilImage(handle, image, imageLayout, pDepthStencil, rangeCount, pRanges);
	}

	void cmdClearAttachments(  uint32_t  attachmentCount, VkClearAttachment const* pAttachments, uint32_t  rectCount, VkClearRect const* pRects){
		rs_check(DispatchTable.vkCmdClearAttachments!=nullptr);
		DispatchTable.vkCmdClearAttachments(handle, attachmentCount, pAttachments, rectCount, pRects);
	}

	void cmdResolveImage(  VkImage  srcImage, VkImageLayout  srcImageLayout, VkImage  dstImage, VkImageLayout  dstImageLayout, uint32_t  regionCount, VkImageResolve const* pRegions){
		rs_check(DispatchTable.vkCmdResolveImage!=nullptr);
		DispatchTable.vkCmdResolveImage(handle, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
	}

	void cmdSetEvent(  VkEvent  event, VkPipelineStageFlags  stageMask){
		rs_check(DispatchTable.vkCmdSetEvent!=nullptr);
		DispatchTable.vkCmdSetEvent(handle, event, stageMask);
	}

	void cmdResetEvent(  VkEvent  event, VkPipelineStageFlags  stageMask){
		rs_check(DispatchTable.vkCmdResetEvent!=nullptr);
		DispatchTable.vkCmdResetEvent(handle, event, stageMask);
	}

	void cmdWaitEvents(  uint32_t  eventCount, VkEvent const* pEvents, VkPipelineStageFlags  srcStageMask, VkPipelineStageFlags  dstStageMask, uint32_t  memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t  bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t  imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers){
		rs_check(DispatchTable.vkCmdWaitEvents!=nullptr);
		DispatchTable.vkCmdWaitEvents(handle, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
	}

	void cmdPipelineBarrier(  VkPipelineStageFlags  srcStageMask, VkPipelineStageFlags  dstStageMask, VkDependencyFlags  dependencyFlags, uint32_t  memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t  bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t  imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers){
		rs_check(DispatchTable.vkCmdPipelineBarrier!=nullptr);
		DispatchTable.vkCmdPipelineBarrier(handle, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
	}

	void cmdBeginQuery(  VkQueryPool  queryPool, uint32_t  query, VkQueryControlFlags  flags){
		rs_check(DispatchTable.vkCmdBeginQuery!=nullptr);
		DispatchTable.vkCmdBeginQuery(handle, queryPool, query, flags);
	}

	void cmdEndQuery(  VkQueryPool  queryPool, uint32_t  query){
		rs_check(DispatchTable.vkCmdEndQuery!=nullptr);
		DispatchTable.vkCmdEndQuery(handle, queryPool, query);
	}

	void cmdResetQueryPool(  VkQueryPool  queryPool, uint32_t  firstQuery, uint32_t  queryCount){
		rs_check(DispatchTable.vkCmdResetQueryPool!=nullptr);
		DispatchTable.vkCmdResetQueryPool(handle, queryPool, firstQuery, queryCount);
	}

	void cmdWriteTimestamp(  VkPipelineStageFlagBits  pipelineStage, VkQueryPool  queryPool, uint32_t  query){
		rs_check(DispatchTable.vkCmdWriteTimestamp!=nullptr);
		DispatchTable.vkCmdWriteTimestamp(handle, pipelineStage, queryPool, query);
	}

	void cmdCopyQueryPoolResults(  VkQueryPool  queryPool, uint32_t  firstQuery, uint32_t  queryCount, VkBuffer  dstBuffer, VkDeviceSize  dstOffset, VkDeviceSize  stride, VkQueryResultFlags  flags){
		rs_check(DispatchTable.vkCmdCopyQueryPoolResults!=nullptr);
		DispatchTable.vkCmdCopyQueryPoolResults(handle, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
	}

	void cmdPushConstants(  VkPipelineLayout  layout, VkShaderStageFlags  stageFlags, uint32_t  offset, uint32_t  size, void const* pValues){
		rs_check(DispatchTable.vkCmdPushConstants!=nullptr);
		DispatchTable.vkCmdPushConstants(handle, layout, stageFlags, offset, size, pValues);
	}

	void cmdBeginRenderPass(  VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassContents  contents){
		rs_check(DispatchTable.vkCmdBeginRenderPass!=nullptr);
		DispatchTable.vkCmdBeginRenderPass(handle, pRenderPassBegin, contents);
	}

	void cmdNextSubpass(  VkSubpassContents  contents){
		rs_check(DispatchTable.vkCmdNextSubpass!=nullptr);
		DispatchTable.vkCmdNextSubpass(handle, contents);
	}

	void cmdEndRenderPass( ){
		rs_check(DispatchTable.vkCmdEndRenderPass!=nullptr);
		DispatchTable.vkCmdEndRenderPass(handle);
	}

	void cmdExecuteCommands(  uint32_t  commandBufferCount, VkCommandBuffer const* pCommandBuffers){
		rs_check(DispatchTable.vkCmdExecuteCommands!=nullptr);
		DispatchTable.vkCmdExecuteCommands(handle, commandBufferCount, pCommandBuffers);
	}

	void cmdDebugMarkerBeginEXT(  VkDebugMarkerMarkerInfoEXT const* pMarkerInfo){
		rs_check(DispatchTable.vkCmdDebugMarkerBeginEXT!=nullptr);
		DispatchTable.vkCmdDebugMarkerBeginEXT(handle, pMarkerInfo);
	}

	void cmdDebugMarkerEndEXT( ){
		rs_check(DispatchTable.vkCmdDebugMarkerEndEXT!=nullptr);
		DispatchTable.vkCmdDebugMarkerEndEXT(handle);
	}

	void cmdDebugMarkerInsertEXT(  VkDebugMarkerMarkerInfoEXT const* pMarkerInfo){
		rs_check(DispatchTable.vkCmdDebugMarkerInsertEXT!=nullptr);
		DispatchTable.vkCmdDebugMarkerInsertEXT(handle, pMarkerInfo);
	}

	void cmdPushDescriptorSetKHR(  VkPipelineBindPoint  pipelineBindPoint, VkPipelineLayout  layout, uint32_t  set, uint32_t  descriptorWriteCount, VkWriteDescriptorSet const* pDescriptorWrites){
		rs_check(DispatchTable.vkCmdPushDescriptorSetKHR!=nullptr);
		DispatchTable.vkCmdPushDescriptorSetKHR(handle, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
	}

	void cmdSetDeviceMask(  uint32_t  deviceMask){
		rs_check(DispatchTable.vkCmdSetDeviceMask!=nullptr);
		DispatchTable.vkCmdSetDeviceMask(handle, deviceMask);
	}

	void cmdSetDeviceMaskKHR(  uint32_t  deviceMask){
		rs_check(DispatchTable.vkCmdSetDeviceMaskKHR!=nullptr);
		DispatchTable.vkCmdSetDeviceMaskKHR(handle, deviceMask);
	}

	void cmdDispatchBase(  uint32_t  baseGroupX, uint32_t  baseGroupY, uint32_t  baseGroupZ, uint32_t  groupCountX, uint32_t  groupCountY, uint32_t  groupCountZ){
		rs_check(DispatchTable.vkCmdDispatchBase!=nullptr);
		DispatchTable.vkCmdDispatchBase(handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
	}

	void cmdDispatchBaseKHR(  uint32_t  baseGroupX, uint32_t  baseGroupY, uint32_t  baseGroupZ, uint32_t  groupCountX, uint32_t  groupCountY, uint32_t  groupCountZ){
		rs_check(DispatchTable.vkCmdDispatchBaseKHR!=nullptr);
		DispatchTable.vkCmdDispatchBaseKHR(handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
	}

	void cmdPushDescriptorSetWithTemplateKHR(  VkDescriptorUpdateTemplate  descriptorUpdateTemplate, VkPipelineLayout  layout, uint32_t  set, void const* pData){
		rs_check(DispatchTable.vkCmdPushDescriptorSetWithTemplateKHR!=nullptr);
		DispatchTable.vkCmdPushDescriptorSetWithTemplateKHR(handle, descriptorUpdateTemplate, layout, set, pData);
	}

	void cmdSetSampleLocationsEXT(  VkSampleLocationsInfoEXT const* pSampleLocationsInfo){
		rs_check(DispatchTable.vkCmdSetSampleLocationsEXT!=nullptr);
		DispatchTable.vkCmdSetSampleLocationsEXT(handle, pSampleLocationsInfo);
	}

	void cmdBeginRenderPass2(  VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassBeginInfo const* pSubpassBeginInfo){
		rs_check(DispatchTable.vkCmdBeginRenderPass2!=nullptr);
		DispatchTable.vkCmdBeginRenderPass2(handle, pRenderPassBegin, pSubpassBeginInfo);
	}

	void cmdBeginRenderPass2KHR(  VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassBeginInfo const* pSubpassBeginInfo){
		rs_check(DispatchTable.vkCmdBeginRenderPass2KHR!=nullptr);
		DispatchTable.vkCmdBeginRenderPass2KHR(handle, pRenderPassBegin, pSubpassBeginInfo);
	}

	void cmdNextSubpass2(  VkSubpassBeginInfo const* pSubpassBeginInfo, VkSubpassEndInfo const* pSubpassEndInfo){
		rs_check(DispatchTable.vkCmdNextSubpass2!=nullptr);
		DispatchTable.vkCmdNextSubpass2(handle, pSubpassBeginInfo, pSubpassEndInfo);
	}

	void cmdNextSubpass2KHR(  VkSubpassBeginInfo const* pSubpassBeginInfo, VkSubpassEndInfo const* pSubpassEndInfo){
		rs_check(DispatchTable.vkCmdNextSubpass2KHR!=nullptr);
		DispatchTable.vkCmdNextSubpass2KHR(handle, pSubpassBeginInfo, pSubpassEndInfo);
	}

	void cmdEndRenderPass2(  VkSubpassEndInfo const* pSubpassEndInfo){
		rs_check(DispatchTable.vkCmdEndRenderPass2!=nullptr);
		DispatchTable.vkCmdEndRenderPass2(handle, pSubpassEndInfo);
	}

	void cmdEndRenderPass2KHR(  VkSubpassEndInfo const* pSubpassEndInfo){
		rs_check(DispatchTable.vkCmdEndRenderPass2KHR!=nullptr);
		DispatchTable.vkCmdEndRenderPass2KHR(handle, pSubpassEndInfo);
	}

	void cmdDrawIndirectCount(  VkBuffer  buffer, VkDeviceSize  offset, VkBuffer  countBuffer, VkDeviceSize  countBufferOffset, uint32_t  maxDrawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndirectCount!=nullptr);
		DispatchTable.vkCmdDrawIndirectCount(handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
	}

	void cmdDrawIndirectCountKHR(  VkBuffer  buffer, VkDeviceSize  offset, VkBuffer  countBuffer, VkDeviceSize  countBufferOffset, uint32_t  maxDrawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndirectCountKHR!=nullptr);
		DispatchTable.vkCmdDrawIndirectCountKHR(handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
	}

	void cmdDrawIndexedIndirectCount(  VkBuffer  buffer, VkDeviceSize  offset, VkBuffer  countBuffer, VkDeviceSize  countBufferOffset, uint32_t  maxDrawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndexedIndirectCount!=nullptr);
		DispatchTable.vkCmdDrawIndexedIndirectCount(handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
	}

	void cmdDrawIndexedIndirectCountKHR(  VkBuffer  buffer, VkDeviceSize  offset, VkBuffer  countBuffer, VkDeviceSize  countBufferOffset, uint32_t  maxDrawCount, uint32_t  stride){
		rs_check(DispatchTable.vkCmdDrawIndexedIndirectCountKHR!=nullptr);
		DispatchTable.vkCmdDrawIndexedIndirectCountKHR(handle, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
	}

	void cmdBindTransformFeedbackBuffersEXT(  uint32_t  firstBinding, uint32_t  bindingCount, VkBuffer const* pBuffers, VkDeviceSize const* pOffsets, VkDeviceSize const* pSizes){
		rs_check(DispatchTable.vkCmdBindTransformFeedbackBuffersEXT!=nullptr);
		DispatchTable.vkCmdBindTransformFeedbackBuffersEXT(handle, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
	}

	void cmdBeginTransformFeedbackEXT(  uint32_t  firstCounterBuffer, uint32_t  counterBufferCount, VkBuffer const* pCounterBuffers, VkDeviceSize const* pCounterBufferOffsets){
		rs_check(DispatchTable.vkCmdBeginTransformFeedbackEXT!=nullptr);
		DispatchTable.vkCmdBeginTransformFeedbackEXT(handle, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
	}

	void cmdEndTransformFeedbackEXT(  uint32_t  firstCounterBuffer, uint32_t  counterBufferCount, VkBuffer const* pCounterBuffers, VkDeviceSize const* pCounterBufferOffsets){
		rs_check(DispatchTable.vkCmdEndTransformFeedbackEXT!=nullptr);
		DispatchTable.vkCmdEndTransformFeedbackEXT(handle, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
	}

	void cmdBeginQueryIndexedEXT(  VkQueryPool  queryPool, uint32_t  query, VkQueryControlFlags  flags, uint32_t  index){
		rs_check(DispatchTable.vkCmdBeginQueryIndexedEXT!=nullptr);
		DispatchTable.vkCmdBeginQueryIndexedEXT(handle, queryPool, query, flags, index);
	}

	void cmdEndQueryIndexedEXT(  VkQueryPool  queryPool, uint32_t  query, uint32_t  index){
		rs_check(DispatchTable.vkCmdEndQueryIndexedEXT!=nullptr);
		DispatchTable.vkCmdEndQueryIndexedEXT(handle, queryPool, query, index);
	}

	void cmdDrawIndirectByteCountEXT(  uint32_t  instanceCount, uint32_t  firstInstance, VkBuffer  counterBuffer, VkDeviceSize  counterBufferOffset, uint32_t  counterOffset, uint32_t  vertexStride){
		rs_check(DispatchTable.vkCmdDrawIndirectByteCountEXT!=nullptr);
		DispatchTable.vkCmdDrawIndirectByteCountEXT(handle, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
	}

	void cmdSetLineStippleEXT(  uint32_t  lineStippleFactor, uint16_t  lineStipplePattern){
		rs_check(DispatchTable.vkCmdSetLineStippleEXT!=nullptr);
		DispatchTable.vkCmdSetLineStippleEXT(handle, lineStippleFactor, lineStipplePattern);
	}

	void cmdSetFragmentShadingRateKHR(  VkExtent2D const* pFragmentSize, VkFragmentShadingRateCombinerOpKHR const combinerOps[2]){
		rs_check(DispatchTable.vkCmdSetFragmentShadingRateKHR!=nullptr);
		DispatchTable.vkCmdSetFragmentShadingRateKHR(handle, pFragmentSize, combinerOps);
	}
};

struct WQueue{
	VkQueue handle;
	VkInstDispatchTable& DispatchTable;
	WQueue(VkQueue inHandle, VkInstDispatchTable& inDispatchTable)
	: handle{ inHandle }
	, DispatchTable{ inDispatchTable }
	{}

	VkResult queueSubmit(  uint32_t  submitCount, VkSubmitInfo const* pSubmits, VkFence  fence){
		rs_check(DispatchTable.vkQueueSubmit!=nullptr);
		return DispatchTable.vkQueueSubmit(handle, submitCount, pSubmits, fence);
	}

	VkResult queueWaitIdle( ){
		rs_check(DispatchTable.vkQueueWaitIdle!=nullptr);
		return DispatchTable.vkQueueWaitIdle(handle);
	}

	VkResult queueBindSparse(  uint32_t  bindInfoCount, VkBindSparseInfo const* pBindInfo, VkFence  fence){
		rs_check(DispatchTable.vkQueueBindSparse!=nullptr);
		return DispatchTable.vkQueueBindSparse(handle, bindInfoCount, pBindInfo, fence);
	}

	VkResult queuePresentKHR(  VkPresentInfoKHR const* pPresentInfo){
		rs_check(DispatchTable.vkQueuePresentKHR!=nullptr);
		return DispatchTable.vkQueuePresentKHR(handle, pPresentInfo);
	}
};